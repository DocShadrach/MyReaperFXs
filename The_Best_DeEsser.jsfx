desc: The Best DeEsser (DocShadrach)
// Ported and enhanced from Airwindows DeBess
// Original algorithm by Chris Johnson (www.airwindows.com)
// 
// License: MIT License
// Copyright (c) 2024 Airwindows
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

slider1:0<0,1,0.01>Sensitivity (Intensity)
slider2:0.5<0,1,0.01>Sibilance Focus (Sharpness)
slider3:0.5<0,1,0.01>Max Reduction (Depth)
slider4:0.5<0,1,0.01>Smoothing (Filter)
slider5:0<0,1,1{Output (Processed),Delta (Sibilance Only)}>Monitor
slider7:0<0,1,1{Off,On}>Relative Detection

@init
// Memory buffers to replicate C++ arrays from the original source
sL = 0;   // L Channel Sample Buffer
sR = 100; // R Channel Sample Buffer
mL = 200; // L Channel Derivative Buffer
mR = 300; // R Channel Derivative Buffer

ratioAL = ratioBL = 1.0;
iirSampleAL = iirSampleBL = 0.0;
ratioAR = ratioBR = 1.0;
iirSampleAR = iirSampleBR = 0.0;

flip = 0;

// Constants to avoid errors with the letter 'e' in the JSFX compiler
denorm = 1.18 * pow(10, -23);
dither = 1.18 * pow(10, -17);

// Dither initialization (Airwindows random seed logic)
fpdL = 1.0; while (fpdL < 16386) ( fpdL = rand(4294967295); );
fpdR = 1.0; while (fpdR < 16386) ( fpdR = rand(4294967295); );

// Variables for parameter smoothing and UI meters
sm_s1 = slider1;
sm_s2 = slider2;
sm_s3 = slider3;
sm_s4 = slider4;
gr_meter = 1.0;
det_led = 0; 
env_follower = 0.05; 
is_stereo = 1; // Initialized to avoid undefined error

@slider
overallscale = srate / 44100.0;
monitoring = slider5;
rel_mode = slider7;

@sample
// Parameter Smoothing (20ms ramp to prevent clicks during automation)
sc = 1 - exp(-1 / (srate * 0.02)); 
sm_s1 += (slider1 - sm_s1) * sc;
sm_s2 += (slider2 - sm_s2) * sc;
sm_s3 += (slider3 - sm_s3) * sc;
sm_s4 += (slider4 - sm_s4) * sc;

inputSampleL = spl0;
inputSampleR = spl1;

// STATE DETECTION: Automatic Mono/Stereo detection
is_stereo = (inputSampleL != inputSampleR);

// Envelope follower for Relative Detection (Anti-Pumping logic)
abs_picos = max(abs(inputSampleL), abs(inputSampleR));
env_follower += (abs_picos - env_follower) * (abs_picos > env_follower ? 0.5 : 0.001);

// Original mathematical mapping with smoothed slider values
intensity = (sm_s1^5) * (8192 / overallscale);
sharpness = sm_s2 * 40.0;
sharpness < 2 ? sharpness = 2;
speed = 0.1 / sharpness;
depth_limit = 1.0 / (sm_s3 + 0.0001);
iirAmount = sm_s4;

// Denormal protection
abs(inputSampleL) < denorm ? inputSampleL = fpdL * dither;
abs(inputSampleR) < denorm ? inputSampleR = fpdR * dither;

sL[0] = inputSampleL;
sR[0] = inputSampleR;

// Slew History (must run on both to keep buffers synchronized)
x = floor(sharpness);
while (x > 0) (
  sL[x] = sL[x-1];
  sR[x] = sR[x-1];
  x -= 1;
);

// Second-order derivatives (Sibilance acceleration detection)
mL[1] = (sL[1] - sL[2]) * ((sL[1] - sL[2]) / 1.3);
is_stereo ? ( mR[1] = (sR[1] - sR[2]) * ((sR[1] - sR[2]) / 1.3); );

x = floor(sharpness - 1);
while (x > 1) (
  mL[x] = (sL[x] - sL[x+1]) * ((sL[x-1] - sL[x]) / 1.3);
  is_stereo ? ( mR[x] = (sR[x] - sR[x+1]) * ((sR[x-1] - sR[x]) / 1.3); );
  x -= 1;
);

// Pure sibilance detection logic
senseL = abs(mL[1] - mL[2]) * sharpness * sharpness;
senseR = senseL; // Default for mono optimization
is_stereo ? ( senseR = abs(mR[1] - mR[2]) * sharpness * sharpness; );

x = floor(sharpness - 1);
while (x > 0) (
  multL = abs(mL[x] - mL[x+1]) * sharpness * sharpness;
  multL < 1.0 ? senseL *= multL;
  is_stereo ? (
    multR = abs(mR[x] - mR[x+1]) * sharpness * sharpness;
    multR < 1.0 ? senseR *= multR;
  );
  x -= 1;
);

// Texture Compensation (Relative Detection - prevents pumping on loud passages)
rel_mode ? (
    comp_factor = 1.0 / (env_follower + 0.001);
    senseL *= (comp_factor * 0.15); 
    senseR *= (comp_factor * 0.15);
);

// LED triggers if sibilance is detected, regardless of sensitivity intensity
max(senseL, senseR) > 0.5 ? det_led = 1.0 : det_led *= 0.9998; 

senseL = 1.0 + (intensity * intensity * senseL);
senseR = 1.0 + (intensity * intensity * senseR);

senseL > intensity ? senseL = intensity;
senseR > intensity ? senseR = intensity;

// Interleaved IIR filtering (Airwindows signature technique)
flip ? (
  iirSampleAL = (iirSampleAL * (1 - iirAmount)) + (inputSampleL * iirAmount);
  ratioAL = (ratioAL * (1.0 - speed)) + (senseL * speed);
  ratioAL > depth_limit ? ratioAL = depth_limit;
  ratioAL > 1.0 ? inputSampleL = iirSampleAL + ((inputSampleL - iirSampleAL) / ratioAL);
  
  iirSampleAR = (iirSampleAR * (1 - iirAmount)) + (inputSampleR * iirAmount);
  ratioAR = (ratioAR * (1.0 - speed)) + (senseR * speed);
  ratioAR > depth_limit ? ratioAR = depth_limit;
  ratioAR > 1.0 ? inputSampleR = iirSampleAR + ((inputSampleR - iirSampleAR) / ratioAR);
) : (
  iirSampleBL = (iirSampleBL * (1 - iirAmount)) + (inputSampleL * iirAmount);
  ratioBL = (ratioBL * (1.0 - speed)) + (senseL * speed);
  ratioBL > depth_limit ? ratioBL = depth_limit;
  ratioBL > 1.0 ? inputSampleL = iirSampleBL + ((inputSampleL - iirSampleBL) / ratioBL);
  
  iirSampleBR = (iirSampleBR * (1 - iirAmount)) + (inputSampleR * iirAmount);
  ratioBR = (ratioBR * (1.0 - speed)) + (senseR * speed);
  ratioBR > depth_limit ? ratioBR = depth_limit;
  ratioBR > 1.0 ? inputSampleR = iirSampleBR + ((inputSampleR - iirSampleBR) / ratioBR);
);
flip = 1 - flip;

// Gain Reduction meter capture (inverse of the applied ratio)
current_max_ratio = max(max(ratioAL, ratioBL), max(ratioAR, ratioBR));
gr_meter = min(gr_meter, 1.0 / current_max_ratio);

// Delta Monitoring (Audition what is being removed)
monitoring > 0.49999 ? (
  inputSampleL = spl0 - inputSampleL;
  inputSampleR = spl1 - inputSampleR;
);

// Final Dither Output
fpdL = (fpdL ^ (fpdL << 13)) & 0xFFFFFFFF; 
fpdL = (fpdL ^ (fpdL >> 17)) & 0xFFFFFFFF; 
fpdL = (fpdL ^ (fpdL << 5)) & 0xFFFFFFFF;
fpdR = (fpdR ^ (fpdR << 13)) & 0xFFFFFFFF; 
fpdR = (fpdR ^ (fpdR << 17)) & 0xFFFFFFFF; 
fpdR = (fpdR ^ (fpdR << 5)) & 0xFFFFFFFF;

spl0 = inputSampleL;
spl1 = inputSampleR;

@gfx 180 40
// 1. Draw Gain Reduction meter (Top bar)
gfx_r = 0.2; gfx_g = 0.8; gfx_b = 1.0; gfx_a = 0.8;
meter_h = 12;
meter_w = (1 - gr_meter) * gfx_w;
gfx_rect(0, 0, meter_w, meter_h);

// 2. Draw Detection LED
det_led > 0.01 ? (
  gfx_r = 1.0; gfx_g = 0.9; gfx_b = 0.0; gfx_a = det_led;
  gfx_circle(gfx_w - 20, 25, 6, 1);
  gfx_r = 1.0; gfx_g = 1.0; gfx_b = 1.0; gfx_a = 0.7;
  gfx_x = gfx_w - 85; gfx_y = 20;
  gfx_drawstr("DETECT");
);

// 3. Draw Reduction and Format text
gr_db = 20 * log10(gr_meter);
gfx_x = 5; gfx_y = 20;
gfx_r = 0.8; gfx_g = 0.8; gfx_b = 0.8; gfx_a = 1.0;
gr_db < -0.1 ? (
  gfx_drawstr("Reduction: ");
  gfx_drawnumber(gr_db, 1);
  gfx_drawstr(" dB  ");
);
gfx_r = 0.4; gfx_g = 0.4; gfx_b = 0.4;
is_stereo ? gfx_drawstr("[Stereo Mode]") : gfx_drawstr("[Mono Mode]");

// Slow returns for visual fluidity
gr_meter += (1.0 - gr_meter) * 0.05;
det_led *= 0.9;
