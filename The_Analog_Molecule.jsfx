desc: The Analog Molecule (DocShadrach)
// author: Doc Shadrach
// version: 1.7
// about: Professional 180-Channel 3D Console Emulator.
// 
// This plugin uses DSP algorithms by Chris Johnson (Airwindows)
// derived from 'Interstage' and 'Console9', released under the MIT License.
// Global network and thermal bloom architecture by Doc Shadrach.
// 

options:gmem=AnalogMoleculeNetwork

slider1:t_id=1<1,180,1>Analog Channel ID
slider2:t_topo=0<0,2,1{Channel (Discrete),Bus (Transformer),Master (Main Leader)}>Topology
slider3:t_calib_mode=1<0,1,1{Hot (0dB),Normal (-4dB)}>Bus Calibration
slider4:t_flux=20<0,100,0.5>3D Flux (Phase Depth) %
slider5:t_thermal=20<0,100,0.5>Thermal Bloom (Inertia) %
slider6:t_analog=12<0,100,1>Analog Texture (Interstage) %
slider7:t_drive=0<-12,12,0.1>Compensated Drive (dB)
slider8:t_bypass=0<0,1,1{Active,Bypassed}>Global State
slider10:t_xtalk=0<0,1,1{Off,On}>Analog Crosstalk
slider11:t_xt_mode=0<0,2,1{Vintage (-75dB),Modern (-95dB),Boutique (-115dB)}>-Master XT Mode
slider64:s_init_done=0<0,1,1>-

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

@init
inv_srate = 1/srate;
overallscale = srate / 44100.0;
firstStage = 0.381966011250105 / overallscale;
iirAmount = 0.00295 / overallscale;
ist_threshold_base = 0.381966011250105;
smooth = exp(-inv_srate / 0.045);
thermal_rel = exp(-inv_srate / 2.5);

// --- OPTIMIZED PHYSICS CONSTANTS ---
// Calculated once on init. Defines the capacitor charge time (25ms).
// This ensures identical behavior at any sample rate or buffer size.
rail_loss = 1.0 - exp(-inv_srate / 0.025);

instance_id = rand(1000000) + 1; 
last_global_sync = gmem[0];
last_global_bypass = gmem[7];
last_global_xtalk = gmem[21];
last_global_calib = gmem[22];
last_global_xt_mode = gmem[23]; 

// State variables
istL_A1=0; istL_B1=0; istL_A2=0; istL_B2=0; istL_A3=0; istL_B3=0;
istR_A1=0; istR_B1=0; istR_A2=0; istR_B2=0; istR_A3=0; istR_B3=0;
lastL=0; lastR=0; flip=0; heatL=0; heatR=0; apL=0; apR=0; hpL=0; hpR = 0;
s_flux=0; s_thermal=0; s_analog=0; s_calib=1; s_out = 1; s_bypass=1;
meter_input = 0;
g_clock = 0;
m_watchdog_time = 0;
has_master = 0;
last_topo = t_topo;

energy_accum = 0;
buffered_rail = 0;
rail_target = 0;
xt_leak = 0; 

xt_lp=0; xt_hp=0;
xt_gain = 10^(-75/20); 

// MEMORY MAP CONSTANTS
PTR_BANK = 15;      
BANK_A_OFFSET = 200; 
BANK_B_OFFSET = 300; 

// SAFETY INITIALIZATION
(gmem[PTR_BANK] < 0 || gmem[PTR_BANK] > 1) ? gmem[PTR_BANK] = 0;

@slider
// v1.7: NEW DEFAULTS FOR MODERN WORKFLOW (Faster Transients)
t_topo != last_topo ? (
  t_topo == 0 ? ( t_flux = 20; t_thermal = 20; t_analog = 12; ) : 
  t_topo == 1 ? ( t_flux = 12; t_thermal = 30; t_analog = 15; ) : 
  t_topo == 2 ? ( t_flux = 8; t_thermal = 20; t_analog = 10; );
  slider_automate(t_flux); slider_automate(t_thermal); slider_automate(t_analog);
  last_topo = t_topo;
);

gmem[7] = t_bypass;
gmem[21] = t_xtalk; 
gmem[22] = t_calib_mode; 
t_topo == 2 ? ( gmem[23] = t_xt_mode; );

last_global_bypass = t_bypass;
last_global_xtalk = t_xtalk;
last_global_calib = t_calib_mode;
last_global_xt_mode = gmem[23];

unit_seed = t_id / 180;
cluster_id = floor((t_id - 1) / 18); 

topo_offset = 0.0;
t_topo == 1 ? ( topo_offset = (t_calib_mode == 1) ? -4.0 : 0.0; );
t_topo == 2 ? topo_offset = -8.0; 

target_calib = 10^((t_drive + topo_offset) / 20);
target_out = 10^(-(t_drive + topo_offset) / 20);
target_bypass = 1.0 - t_bypass; 

@block
s_init_done == 0 ? ( 
  t_topo < 2 ? (
    my_slot = atomic_add(gmem[1], 1); 
    t_id = ((my_slot * 37) % 180) + 1; 
  ) : ( t_id = 1; );
  slider_automate(t_id); 
  unit_seed = t_id / 180;
  cluster_id = floor((t_id - 1) / 18);
  s_init_done = 1; 
);

gmem[0] != last_global_sync ? (
  t_topo < 2 ? (
    my_index = atomic_add(gmem[1], 1);
    t_id = ((my_index * 37 + gmem[11]) % 180) + 1;
    slider_automate(t_id); 
    unit_seed = t_id / 180;
    cluster_id = floor((t_id - 1) / 18);
  );
  last_global_sync = gmem[0];
);

t_topo == 2 ? (
  gmem[30] = instance_id; 
  gmem[31] += 1; 
  has_master = 1;
  gmem[23] = t_xt_mode; 
) : (
  gmem[30] == instance_id ? gmem[30] = 0; 
);

block_duration = samplesblock * inv_srate;
gmem[31] != last_h_tick ? (
  has_master = 1; last_h_tick = gmem[31]; m_watchdog_time = 0;
) : (
  m_watchdog_time += block_duration;
  m_watchdog_time > 0.5 ? has_master = 0; 
);

t_topo == 2 && gmem[30] != instance_id ? (
  t_topo = 1; slider_automate(t_topo);
  topo_offset = (t_calib_mode == 1) ? -4.0 : 0.0;
  target_calib = 10^((t_drive + topo_offset) / 20);
  target_out = 10^(-(t_drive + topo_offset) / 20);
);

gmem[7] != last_global_bypass ? ( t_bypass = gmem[7]; last_global_bypass = gmem[7]; slider_automate(t_bypass); );
gmem[21] != last_global_xtalk ? ( t_xtalk = gmem[21]; last_global_xtalk = t_xtalk; slider_automate(t_xtalk); );
gmem[23] != last_global_xt_mode ? (
  t_topo != 2 ? ( t_xt_mode = gmem[23]; slider_automate(t_xt_mode); );
  last_global_xt_mode = gmem[23];
);

target_xt_db = (t_xt_mode == 0) ? -75.0 : (t_xt_mode == 1) ? -95.0 : -115.0;
xt_gain = 10^(target_xt_db/20);

gmem[22] != last_global_calib ? ( 
  t_calib_mode = gmem[22]; last_global_calib = t_calib_mode; slider_automate(t_calib_mode); 
  t_topo == 1 ? topo_offset = (t_calib_mode == 1) ? -4.0 : 0.0;
  t_topo == 2 ? topo_offset = -8.0;
  t_topo == 0 ? topo_offset = 0.0;
  target_calib = 10^((t_drive + topo_offset) / 20);
  target_out = 10^(-(t_drive + topo_offset) / 20);
);

target_flux = t_flux / 100; target_thermal = t_thermal / 100; target_analog = t_analog / 100; target_bypass = 1.0 - t_bypass;

// v1.7: Bus Interstage penalty reduced (0.7 -> 0.85) to prevent transient eating
topology_interstage = t_topo == 0 ? 1.0 : 0.85; 
topology_flux_depth = t_topo == 0 ? 1.0 : 0.3; 

t_bypass == 0 ? ( atomic_add(gmem[10], energy_accum * 0.000015); );
energy_accum = 0;
t_topo == 2 ? ( gmem[10] *= pow(0.998, samplesblock); );

// Capture the target rail voltage for this block
rail_target = gmem[10];

@sample
rawL = spl0; rawR = spl1;
s_flux = s_flux * smooth + target_flux * (1 - smooth);
s_thermal = s_thermal * smooth + target_thermal * (1 - smooth);
s_analog = s_analog * smooth + target_analog * (1 - smooth);
s_calib = s_calib * smooth + target_calib * (1 - smooth);
s_out = s_out * smooth + target_out * (1 - smooth);
s_bypass = s_bypass * smooth + target_bypass * (1 - smooth);

sL = rawL * s_calib; sR = rawR * s_calib;
dryL = sL; dryR = sR; 
peak = max(abs(sL), abs(sR));
meter_input = (peak > meter_input) ? (meter_input * 0.4 + peak * 0.6) : (meter_input * 0.9992 + peak * 0.0008);

// NETWORK CLOCK & DOUBLE BUFFER SWAP (Atomic Safe)
g_clock += 1;
t_topo == 2 && (g_clock > 128) ? ( 
  g_clock = 0;
  current_read = gmem[PTR_BANK]; // 0 or 1
  next_read = 1 - current_read; 
  xi = 0; loop(10, gmem[BANK_A_OFFSET + xi + (next_read * 100)] = 0; xi += 1; );
  gmem[PTR_BANK] = next_read;
);

xt_leak = 0;

(t_bypass == 0) ? (
  
  // 4.5 DOUBLE BUFFERED CROSSTALK ENGINE
  t_xtalk ? (
    read_bank_offset = gmem[PTR_BANK] * 100;      
    write_bank_offset = (1 - gmem[PTR_BANK]) * 100; 
    
    xt_mono = (sL + sR) * 0.5;
    xt_lp = xt_lp * 0.85 + xt_mono * 0.15;
    xt_hp = xt_hp * 0.98 + xt_lp * 0.02;
    xt_final = xt_lp - xt_hp;
    
    atomic_add(gmem[BANK_A_OFFSET + cluster_id + write_bank_offset], xt_final);
    xt_sum = gmem[BANK_A_OFFSET + cluster_id + read_bank_offset];
    xt_leak = (xt_sum - xt_final) * xt_gain;
    
    sL += xt_leak * s_bypass; 
    sR += xt_leak * s_bypass;
  );

  flux_freq = 16500 - (unit_seed * (6500 * topology_flux_depth)); 
  flux_coeff = (1 - s_flux * 0.12) * (flux_freq * inv_srate);
  apL_in = sL; sL = (apL_in * (flux_coeff - 1) + apL) / (1 + flux_coeff); apL = apL_in + sL * flux_coeff;
  apR_in = sR; sR = (apR_in * (flux_coeff - 1) + apR) / (1 + flux_coeff); apR = apR_in + sR * flux_coeff;

  // --- OPTIMIZED RAIL PHYSICS (Leaky Integrator) ---
  buffered_rail += (rail_target - buffered_rail) * rail_loss;
  
  shared_sag = 1.0 / (1.0 + buffered_rail * 0.04);
  
  // v1.7 FORMULA: (2.40 - s_analog) provides higher slew headroom for modern transients.
  slew_t = ist_threshold_base * (2.40 - s_analog) * shared_sag * topology_interstage; 
  inL = (sL + lastL) * 0.5; inR = (sR + lastR) * 0.5;

  (flip == 0) ? (
    istL_A1 = (istL_A1 * (1 - firstStage)) + (inL * firstStage); inL = istL_A1;
    istL_A2 = (istL_A2 * (1 - iirAmount)) + (inL * iirAmount); inL = istL_A2;
    istL_A3 = (istL_A3 * (1 - iirAmount)) + (inL * iirAmount); inputL = istL_A3;
    sL = dryL - (inputL * s_analog);
    (sL - istL_A1 > slew_t) ? sL = istL_A1 + slew_t : (sL - istL_A1 < -slew_t) ? sL = istL_A1 - slew_t;
    istR_A1 = (istR_A1 * (1 - firstStage)) + (inR * firstStage); inR = istR_A1;
    istR_A2 = (istR_A2 * (1 - iirAmount)) + (inR * iirAmount); inR = istR_A2;
    istR_A3 = (istR_A3 * (1 - iirAmount)) + (inR * iirAmount); inputR = istR_A3;
    sR = dryR - (inputR * s_analog);
    (sR - istR_A1 > slew_t) ? sR = istR_A1 + slew_t : (sR - istR_A1 < -slew_t) ? sR = istR_A1 - slew_t;
  ) : (
    istL_B1 = (istL_B1 * (1 - firstStage)) + (inL * firstStage); inL = istL_B1;
    istL_B2 = (istL_B2 * (1 - iirAmount)) + (inL * iirAmount); inL = istL_B2;
    istL_B3 = (istL_B3 * (1 - iirAmount)) + (inL * iirAmount); inputL = istL_B3;
    sL = dryL - (inputL * s_analog);
    (sL - istL_B1 > slew_t) ? sL = istL_B1 + slew_t : (sL - istL_B1 < -slew_t) ? sL = istL_B1 - slew_t;
    istR_B1 = (istR_B1 * (1 - firstStage)) + (inR * firstStage); inR = istR_B1;
    istR_B2 = (istR_B2 * (1 - iirAmount)) + (inR * iirAmount); inR = istR_B2;
    istR_B3 = (istR_B3 * (1 - iirAmount)) + (inR * iirAmount); inputR = istR_B3;
    sR = dryR - (inputR * s_analog);
    (sR - istR_B1 > slew_t) ? sR = istR_B1 + slew_t : (sR - istR_B1 < -slew_t) ? sR = istR_B1 - slew_t;
  );
  flip = 1 - flip; lastL = sL; lastR = sR;

  absL = abs(sL); absR = abs(sR);
  heatL = (absL > heatL) ? (absL * 0.05 + heatL * 0.95) : (heatL * thermal_rel + absL * (1 - thermal_rel));
  heatR = (absR > heatR) ? (absR * 0.05 + heatR * 0.95) : (heatR * thermal_rel + absR * (1 - thermal_rel));
  bloomL = 1.0 + (heatL * s_thermal * (t_topo == 0 ? 0.5 : 0.6));
  bloomR = 1.0 + (heatR * s_thermal * (t_topo == 0 ? 0.5 : 0.6));
  sL *= 0.618; sL_target = 1.0 - min(abs(sL), 0.999); 
  (sL > 0.0) ? sL = -(exp(log(sL_target) * (1.618 * bloomL)) - 1) : sL = exp(log(1 + sL) * (1.618 * bloomL)) - 1;
  sR *= 0.618; sR_target = 1.0 - min(abs(sR), 0.999); 
  (sR > 0.0) ? sR = -(exp(log(sR_target) * (1.618 * bloomR)) - 1) : sR = exp(log(1 + sR) * (1.618 * bloomR)) - 1;
  
  current_energy = (abs(sL) + abs(sR)) * 0.5;
  energy_accum += current_energy;

) : (
  // --- STATE SCRUBBER PATH (Smart Decay & Snap) ---
  // Apply decay
  xt_lp *= 0.5; xt_hp *= 0.5;
  apL *= 0.5; apR *= 0.5;
  istL_A1 *= 0.5; istL_B1 *= 0.5; istL_A2 *= 0.5; istL_B2 *= 0.5;
  istR_A1 *= 0.5; istR_B1 *= 0.5; istR_A2 *= 0.5; istR_B2 *= 0.5;
  heatL *= 0.5; heatR *= 0.5;

  // MICRO-OPTIMIZATION: Denormal Protection (Snap to Zero)
  // If values are tiny, kill them to save CPU and ensure silence.
  (abs(xt_lp) < 0.000000001) ? xt_lp = 0;
  (abs(xt_hp) < 0.000000001) ? xt_hp = 0;
  (abs(heatL) < 0.000000001) ? heatL = 0;
  (abs(heatR) < 0.000000001) ? heatR = 0;
  
  sL = rawL * s_calib; sR = rawR * s_calib;
);

procL = sL * s_out; procR = sR * s_out;
hpL = hpL * 0.9999 + procL * 0.0001; hpR = hpR * 0.9999 + procR * 0.0001;
procL -= hpL; procR -= hpR;

spl0 = (procL * s_bypass) + (rawL * (1 - s_bypass));
spl1 = (procR * s_bypass) + (rawR * (1 - s_bypass));

@gfx 550 320
gfx_clear = 28 + 28*256 + 30*65536; 

function draw_meter(val, x, y, w, h, label, color_mode) (
  gfx_set(0.1, 0.1, 0.12, 1); gfx_rect(x, y, w, h); 
  v = min(val, 1.0);
  color_mode == 0 ? gfx_set(0, 0.7, 1, 1) : gfx_set(1, 0.5, 0, 1); 
  gfx_rect(x, y, v*w, h); 
  color_mode == 0 ? ( gfx_set(1, 1, 1, 0.8); gfx_rect(x + w * 0.8 - 1, y - 4, 2, h + 8); );
  gfx_set(1, 1, 1, 0.4); gfx_setfont(1, "Arial", 12);
  gfx_x = x; gfx_y = y - 18; gfx_drawstr(label);
);

function draw_button(x, y, w, h, active, label, r, g, b) (
  active == 2 ? gfx_set(r, g, b, 1) : gfx_set(0.15, 0.15, 0.18, 1);
  gfx_rect(x, y, w, h); 
  gfx_set(1, 1, 1, 0.05); gfx_line(x, y, x+w, y); 
  active == 1 ? ( gfx_set(r, g, b, 0.2); gfx_rect(x, y, w, h); gfx_set(r, g, b, 1); gfx_rect(x, y, 4, h); );
  gfx_set(1, 1, 1, active == 1 ? 1 : 0.4);
  
  // --- MODIFICACIÓN: Tamaño dinámico de fuente ---
  // Si el botón es alto (>25px), usa letra grande (18). Si es pequeño, letra chica (11).
  gfx_setfont(1, "Arial", h > 25 ? 18 : 11, 'b');
  
  gfx_measurestr(label, lw, lh);
  gfx_x = x + (w - lw)/2; gfx_y = y + (h - lh)/2;
  gfx_drawstr(label);
);

gfx_set(1, 1, 1, 0.1); gfx_x = 10; gfx_y = 15; gfx_setfont(1, "Arial", 28, 'b');
gfx_drawstr("THE ANALOG MOLECULE");

draw_meter(min(meter_input * 6.5, 1), 50, 75, 450, 12, "CIRCUIT DRIVE STRENGTH", 0);

r_col = t_bypass == 1 ? 1 : 0;
g_col = t_bypass == 1 ? 0.2 : 1;
b_col = t_bypass == 1 ? 0.2 : 0.5;
draw_button(50, 120, 450, 35, 1, t_bypass == 0 ? "MOLECULAR NETWORK: ACTIVE" : "GLOBAL BYPASS ENGAGED", r_col, g_col, b_col);
(mouse_cap & 1 && !last_cap && mouse_x >= 50 && mouse_x <= 500 && mouse_y >= 120 && mouse_y <= 155) ? ( t_bypass = 1 - t_bypass; gmem[7] = t_bypass; slider_automate(t_bypass); );

is_xt_visually_active = (t_xtalk == 1 && t_bypass == 0);
draw_button(50, 170, 450, 35, is_xt_visually_active, t_xtalk == 1 ? "ANALOG CROSSTALK: ON" : "ANALOG CROSSTALK: OFF", 0.8, 0.4, 1);
(mouse_cap & 1 && !last_cap && mouse_x >= 50 && mouse_x <= 500 && mouse_y >= 170 && mouse_y <= 205) ? ( t_xtalk = 1 - t_xtalk; gmem[21] = t_xtalk; slider_automate(t_xtalk); );

t_topo == 2 ? (
  mode_name = (t_xt_mode == 0) ? "MODE: VINTAGE (-75dB)" : (t_xt_mode == 1) ? "MODE: MODERN (-95dB)" : "MODE: BOUTIQUE (-115dB)";
  xt_mode_state = (t_xtalk == 1 && t_bypass == 0) ? 2 : 0;
  draw_button(50, 207, 450, 20, xt_mode_state, mode_name, 0.2, 0.35, 0.7);
  (mouse_cap & 1 && !last_cap && mouse_x >= 50 && mouse_x <= 500 && mouse_y >= 207 && mouse_y <= 227) ? ( 
    t_xt_mode = (t_xt_mode + 1) % 3; 
    slider_automate(t_xt_mode);
    gmem[23] = t_xt_mode; 
  );
  r_y = 235;
) : (
  gfx_set(1, 1, 1, 0.3); gfx_setfont(1, "Arial", 11);
  slave_mode = (t_xt_mode == 0) ? "VINTAGE" : (t_xt_mode == 1) ? "MODERN" : "BOUTIQUE";
  info_s = sprintf(#, "XT MODE SYNC: %s", slave_mode);
  gfx_measurestr(info_s, iw, ih);
  gfx_x = 50 + (450 - iw)/2; gfx_y = 210;
  gfx_drawstr(info_s);
  r_y = 230;
);

draw_button(85, r_y, 380, 35, 0, "RANDOMIZE CONSOLE TOPOLOGY", 0, 0, 0);
(mouse_cap & 1 && !last_cap && mouse_x >= 85 && mouse_x <= 465 && mouse_y >= r_y && mouse_y <= r_y + 35) ? ( 
  gmem[11] = floor(rand(1000)); 
  gmem[1] = 0; 
  gmem[0] += 1; 
);

has_master == 0 ? (
  gfx_set(1, 0.2, 0.2, 1); gfx_setfont(1, "Arial", 13, 'b');
  warn_s = "WARNING: NO MASTER DETECTED (NETWORK SAG INACTIVE)";
  gfx_measurestr(warn_s, ww, wh);
  gfx_x = 50 + (450 - ww)/2; gfx_y = 275;
  gfx_drawstr(warn_s);
);

gfx_set(1, 1, 1, 0.05); gfx_rect(50, 295, 450, 1);
gfx_set(0.6, 0.6, 0.6, 1); gfx_setfont(1, "Arial", 12);
topo_str = t_topo == 0 ? "CHANNEL" : t_topo == 1 ? "BUS" : "MASTER";
cal_str = (t_topo == 1) ? (t_calib_mode == 0 ? " | CAL: HOT" : " | CAL: NORMAL") : "";
status_str = sprintf(#, "ID: %d | TOPO: %s%s | CLUSTER: %d", t_id, topo_str, cal_str, cluster_id + 1);
gfx_measurestr(status_str, sw, sh);
gfx_x = 50 + (450 - sw)/2; gfx_y = 305;
gfx_drawstr(status_str);

last_cap = mouse_cap;
