desc: The Analog Molecule (DocShadrach)
// author: Doc Shadrach
// version: 1.9
// about: Professional 180-Channel 3D Console Emulator.
// 
// This plugin uses DSP algorithms by Chris Johnson (Airwindows)
// derived from 'Interstage' and 'Console9', released under the MIT License.
// Global network and thermal bloom architecture by Doc Shadrach.
// 

options:gmem=AnalogMoleculeNetwork

slider1:t_id=1<1,180,1>Analog Channel ID
slider2:t_topo=0<0,2,1{Channel (Discrete),Bus (Transformer),Master (Main Leader)}>Topology
slider3:t_calib_mode=1<0,1,1{Hot (0dB),Normal (-4dB)}>Bus Calibration
slider4:t_flux=20<0,100,0.1>3D Flux (Phase Depth) %
slider5:t_thermal=20<0,100,0.1>Thermal Bloom (Inertia) %
slider6:t_analog=12<0,100,0.1>Analog Texture (Interstage) %
slider7:t_drive=0<-12,12,0.1>Compensated Drive (dB)
slider8:t_out_gain=0<-12,12,0.1>Output Gain (dB)
slider9:t_bypass=0<0,1,1{Active,Bypassed}>Global State
slider10:t_xtalk=0<0,1,1{Off,On}>Analog Crosstalk
slider11:t_xt_mode=0<0,2,1{Vintage (-75dB),Modern (-95dB),Boutique (-115dB)}>-Master XT Mode
// UI CONTROL VARIABLES
slider12:t_link_on=0<0,1,1{Off,On}>-Link Active
slider13:t_flavor=0<0,4,1{Custom,British Class A,Solid State E,US Discrete,Modern Mastering}>-Console Flavor
// Slider 14 REMOVED (No Groups)
slider64:s_init_done=0<0,1,1>-

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

@init
inv_srate = 1/srate;
overallscale = srate / 44100.0;
firstStage = 0.381966011250105 / overallscale;
iirAmount = 0.00295 / overallscale;
ist_threshold_base = 0.381966011250105;
smooth = exp(-inv_srate / 0.045);
thermal_rel = exp(-inv_srate / 2.5);

// --- OPTIMIZED PHYSICS CONSTANTS ---
rail_loss = 1.0 - exp(-inv_srate / 0.025);

instance_id = rand(1000000) + 1; 
last_global_sync = gmem[0];
last_global_bypass = gmem[7];
last_global_xtalk = gmem[21];
last_global_calib = gmem[22];
last_global_xt_mode = gmem[23]; 

// Link System Trackers
net_flux_mirror = 0;
net_thermal_mirror = 0;
net_analog_mirror = 0;
net_trim_mirror = 0;

last_flux_int = 0;
last_thermal_int = 0;
last_analog_int = 0;
last_trim_int = 0;

last_flavor = t_flavor;
my_flavor_cmd = 0;

last_link_state = t_link_on;
force_refresh = 1;

loading_preset = 0;
id_conflict = 0; 

// State variables
istL_A1=0; istL_B1=0; istL_A2=0; istL_B2=0; istL_A3=0; istL_B3=0;
istR_A1=0; istR_B1=0; istR_A2=0; istR_B2=0; istR_A3=0; istR_B3=0;
lastL=0; lastR=0; flip=0; heatL=0; heatR=0; apL=0; apR=0; hpL=0; hpR = 0;
s_flux=0; s_thermal=0; s_analog=0; s_calib=1; s_out = 1; s_bypass=1;
meter_input = 0;
g_clock = 0;
m_watchdog_time = 0;
has_master = 0;
last_topo = t_topo;

energy_accum = 0;
buffered_rail = 0;
rail_target = 0;
xt_leak = 0; 

xt_lp=0; xt_hp=0;
xt_gain = 10^(-75/20); 

// MEMORY MAP CONSTANTS
PTR_BANK = 15;      
BANK_A_OFFSET = 200; 
BANK_B_OFFSET = 300; 

// SAFETY INITIALIZATION
(gmem[PTR_BANK] < 0 || gmem[PTR_BANK] > 1) ? gmem[PTR_BANK] = 0;

function to_int(val) ( floor(val * 10 + 0.5); );

// --- PRESET LOADING FUNCTION ---
function load_flavor(flavor_id) (
  loading_preset = 1; 
  flavor_id == 1 ? ( // British Class A
    t_topo == 0 ? ( t_flux=35; t_thermal=40; t_analog=25; );
    t_topo == 1 ? ( t_flux=25; t_thermal=50; t_analog=30; t_calib_mode=0; );
    t_topo == 2 ? ( t_flux=15; t_thermal=30; t_analog=20; t_xt_mode=0; );
  ) : flavor_id == 2 ? ( // Solid State E
    t_topo == 0 ? ( t_flux=20; t_thermal=20; t_analog=15; );
    t_topo == 1 ? ( t_flux=15; t_thermal=35; t_analog=20; t_calib_mode=1; );
    t_topo == 2 ? ( t_flux=10; t_thermal=20; t_analog=12; t_xt_mode=1; );
  ) : flavor_id == 3 ? ( // US Discrete
    t_topo == 0 ? ( t_flux=10; t_thermal=10; t_analog=10; );
    t_topo == 1 ? ( t_flux=10; t_thermal=15; t_analog=12; t_calib_mode=0; );
    t_topo == 2 ? ( t_flux=5; t_thermal=10; t_analog=8; t_xt_mode=0; );
  ) : flavor_id == 4 ? ( // Modern Mastering
    t_topo == 0 ? ( t_flux=5; t_thermal=5; t_analog=5; );
    t_topo == 1 ? ( t_flux=5; t_thermal=5; t_analog=5; t_calib_mode=1; );
    t_topo == 2 ? ( t_flux=2; t_thermal=5; t_analog=2; t_xt_mode=2; );
  );
  slider_automate(t_flux); slider_automate(t_thermal); slider_automate(t_analog); 
  slider_automate(t_calib_mode); slider_automate(t_xt_mode);
  
  last_flux_int = to_int(t_flux);
  last_thermal_int = to_int(t_thermal);
  last_analog_int = to_int(t_analog);
  last_trim_int = to_int(t_out_gain);
  
  loading_preset = 0; 
);

@slider
// HIDE CONTROL SLIDERS
slider_show(t_link_on, 0);
slider_show(t_flavor, 0);

cur_flux_int = to_int(t_flux);
cur_thermal_int = to_int(t_thermal);
cur_analog_int = to_int(t_analog);

// DIRTY STATE CHECK
(loading_preset == 0 && t_flavor > 0 && (cur_flux_int != last_flux_int || cur_thermal_int != last_thermal_int || cur_analog_int != last_analog_int)) ? (
  t_flavor = 0; slider_automate(t_flavor);
);

// DETECT LINK TOGGLE
(t_link_on != last_link_state) ? (
  force_refresh = 1;
  last_link_state = t_link_on;
);

t_topo != last_topo ? (
  t_flavor > 0 ? (
    load_flavor(t_flavor);
  ) : (
    t_topo == 0 ? ( t_flux = 20; t_thermal = 20; t_analog = 12; ) : 
    t_topo == 1 ? ( t_flux = 12; t_thermal = 30; t_analog = 15; ) : 
    t_topo == 2 ? ( t_flux = 8; t_thermal = 20; t_analog = 10; );
    slider_automate(t_flux); slider_automate(t_thermal); slider_automate(t_analog);
  );
  last_topo = t_topo;
  last_flux_int = to_int(t_flux); 
  last_thermal_int = to_int(t_thermal); 
  last_analog_int = to_int(t_analog);
  last_trim_int = to_int(t_out_gain);
  
  my_scope_ch = (t_topo == 0);
  my_scope_bus = (t_topo == 1);
  my_scope_mtr = (t_topo == 2);
  force_refresh = 1;
);

gmem[7] = t_bypass;
gmem[21] = t_xtalk; 
gmem[22] = t_calib_mode; 
t_topo == 2 ? ( gmem[23] = t_xt_mode; );

last_global_bypass = t_bypass;
last_global_xtalk = t_xtalk;
last_global_calib = t_calib_mode;
last_global_xt_mode = gmem[23];

unit_seed = t_id / 180;
cluster_id = floor((t_id - 1) / 18); 

topo_offset = 0.0;
t_topo == 1 ? ( topo_offset = (t_calib_mode == 1) ? -4.0 : 0.0; );
t_topo == 2 ? topo_offset = -8.0; 

target_calib = 10^((t_drive + topo_offset) / 20);
target_out = 10^((t_out_gain - t_drive - topo_offset) / 20);
target_bypass = 1.0 - t_bypass; 

@block
s_init_done == 0 ? ( 
  t_topo < 2 ? (
    my_slot = atomic_add(gmem[1], 1); 
    t_id = ((my_slot * 37) % 180) + 1; 
  ) : ( t_id = 1; );
  slider_automate(t_id); 
  unit_seed = t_id / 180;
  cluster_id = floor((t_id - 1) / 18);
  s_init_done = 1;
  
  last_flux_int = to_int(t_flux); 
  last_thermal_int = to_int(t_thermal); 
  last_analog_int = to_int(t_analog);
  last_trim_int = to_int(t_out_gain);
  last_link_state = t_link_on;
  
  my_scope_ch = (t_topo == 0);
  my_scope_bus = (t_topo == 1);
  my_scope_mtr = (t_topo == 2);
  force_refresh = 1;
);

// --- DUPLICATE ID CHECK ---
chk_addr = 10000 + t_id;
occupant = gmem[chk_addr];
(occupant > 0 && occupant != instance_id) ? id_conflict = 1 : id_conflict = 0;
gmem[chk_addr] = instance_id;

gmem[0] != last_global_sync ? (
  t_topo < 2 ? (
    my_index = atomic_add(gmem[1], 1);
    t_id = ((my_index * 37 + gmem[11]) % 180) + 1;
    slider_automate(t_id); 
    unit_seed = t_id / 180;
    cluster_id = floor((t_id - 1) / 18);
  );
  last_global_sync = gmem[0];
);

// --- BROADCAST LINK ALL ---
bc_addr = 70 + t_topo;

(t_link_on == 1 && last_link_state != 1) ? gmem[bc_addr] = 1;
(last_link_state == 1 && t_link_on != 1) ? gmem[bc_addr] = 0;

bc_val = gmem[bc_addr];
(bc_val == 1 && t_link_on != 1) ? ( t_link_on = 1; slider_automate(t_link_on); force_refresh = 1; );
(bc_val == 0 && t_link_on == 1) ? ( t_link_on = 0; slider_automate(t_link_on); force_refresh = 1; );

last_link_state = t_link_on;

// --- LINKING SYSTEM V4.3 ---
(t_link_on > 0) ? (
  l_base = 5000;
  
  // SELF-PUBLISH ACTIVE STATE
  t_topo == 0 ? gmem[l_base+0] = 1;
  t_topo == 1 ? gmem[l_base+1] = 1;
  t_topo == 2 ? gmem[l_base+2] = 1;

  // Read Network State
  scope_ch_active = gmem[l_base+0];
  scope_bus_active = gmem[l_base+1];
  scope_mtr_active = gmem[l_base+2];
  
  my_bank = 1000 + (t_topo * 1000);

  // SOFT TAKEOVER
  force_refresh ? (
    net_flux_mirror = gmem[my_bank];
    net_thermal_mirror = gmem[my_bank+1];
    net_analog_mirror = gmem[my_bank+2];
    net_trim_mirror = gmem[my_bank+3];
    
    last_flux_int = to_int(t_flux);
    last_thermal_int = to_int(t_thermal);
    last_analog_int = to_int(t_analog);
    last_trim_int = to_int(t_out_gain);
    
    force_refresh = 0;
  );

  // 1. PROCESS NETWORK INCOMING
  g_flux = gmem[my_bank];
  g_thermal = gmem[my_bank+1];
  g_analog = gmem[my_bank+2];
  g_trim = gmem[my_bank+3];
  
  dn_flux = g_flux - net_flux_mirror;
  dn_thermal = g_thermal - net_thermal_mirror;
  dn_analog = g_analog - net_analog_mirror;
  dn_trim = g_trim - net_trim_mirror;
  
  (dn_flux != 0) ? (
    t_flux = max(0, min(100, (to_int(t_flux) + dn_flux) / 10.0));
    slider_automate(t_flux);
    last_flux_int = to_int(t_flux); 
    net_flux_mirror = g_flux;       
    t_flavor = 0; slider_automate(t_flavor);
  );
  (dn_thermal != 0) ? (
    t_thermal = max(0, min(100, (to_int(t_thermal) + dn_thermal) / 10.0));
    slider_automate(t_thermal);
    last_thermal_int = to_int(t_thermal);
    net_thermal_mirror = g_thermal;
    t_flavor = 0; slider_automate(t_flavor);
  );
  (dn_analog != 0) ? (
    t_analog = max(0, min(100, (to_int(t_analog) + dn_analog) / 10.0));
    slider_automate(t_analog);
    last_analog_int = to_int(t_analog);
    net_analog_mirror = g_analog;
    t_flavor = 0; slider_automate(t_flavor);
  );
  (dn_trim != 0) ? (
    t_out_gain += (dn_trim / 10.0);
    slider_automate(t_out_gain);
    target_out = 10^((t_out_gain - t_drive - topo_offset) / 20);
    last_trim_int = to_int(t_out_gain);
    net_trim_mirror = g_trim;
  );

  // 2. PROCESS PRESET SYNC
  net_flavor = gmem[my_bank + 4];
  (net_flavor != 0 && net_flavor != my_flavor_cmd) ? (
    new_flav = (net_flavor == -1) ? 0 : net_flavor;
    t_flavor = new_flav; slider_automate(t_flavor);
    new_flav > 0 ? ( 
      load_flavor(new_flav); 
      last_flux_int = to_int(t_flux); last_thermal_int = to_int(t_thermal); last_analog_int = to_int(t_analog);
    );
    my_flavor_cmd = net_flavor;
  );

  // 3. PROCESS USER OUTGOING
  cur_flux_int = to_int(t_flux);
  cur_thermal_int = to_int(t_thermal);
  cur_analog_int = to_int(t_analog);
  
  du_flux = cur_flux_int - last_flux_int;
  du_thermal = cur_thermal_int - last_thermal_int;
  du_analog = cur_analog_int - last_analog_int;
  
  (du_flux != 0 || du_thermal != 0 || du_analog != 0) ? (
    (t_flavor != 0) ? (
      t_flavor = 0; slider_automate(t_flavor);
      scope_ch_active ? gmem[1000 + 4] = -1;
      scope_bus_active ? gmem[2000 + 4] = -1;
      scope_mtr_active ? gmem[3000 + 4] = -1;
    );

    scope_ch_active ? (
      base = 1000;
      du_flux != 0 ? atomic_add(gmem[base+0], du_flux);
      du_thermal != 0 ? atomic_add(gmem[base+1], du_thermal);
      du_analog != 0 ? atomic_add(gmem[base+2], du_analog);
    );
    scope_bus_active ? (
      base = 2000;
      du_flux != 0 ? atomic_add(gmem[base+0], du_flux);
      du_thermal != 0 ? atomic_add(gmem[base+1], du_thermal);
      du_analog != 0 ? atomic_add(gmem[base+2], du_analog);
    );
    scope_mtr_active ? (
      base = 3000;
      du_flux != 0 ? atomic_add(gmem[base+0], du_flux);
      du_thermal != 0 ? atomic_add(gmem[base+1], du_thermal);
      du_analog != 0 ? atomic_add(gmem[base+2], du_analog);
    );
    
    net_flux_mirror += du_flux;
    net_thermal_mirror += du_thermal;
    net_analog_mirror += du_analog;
    
    last_flux_int = cur_flux_int;
    last_thermal_int = cur_thermal_int;
    last_analog_int = cur_analog_int;
  );
  
  (t_flavor != last_flavor && t_flavor > 0) ? (
    scope_ch_active ? gmem[1000 + 4] = t_flavor;
    scope_bus_active ? gmem[2000 + 4] = t_flavor;
    scope_mtr_active ? gmem[3000 + 4] = t_flavor;
    last_flavor = t_flavor;
  );
  (t_flavor != last_flavor) ? last_flavor = t_flavor;

) : (
  last_flux_int = to_int(t_flux); 
  last_thermal_int = to_int(t_thermal); 
  last_analog_int = to_int(t_analog); 
  last_trim_int = to_int(t_out_gain);
  last_flavor = t_flavor;
  
  // Ensure we stop publishing if link is off
  t_topo == 0 ? gmem[5000+0] = 0;
  t_topo == 1 ? gmem[5000+1] = 0;
  t_topo == 2 ? gmem[5000+2] = 0;
);

// ... (Physics & Audio) ...
t_topo == 2 ? (
  gmem[30] = instance_id; 
  gmem[31] += 1; 
  has_master = 1;
  gmem[23] = t_xt_mode; 
) : (
  gmem[30] == instance_id ? gmem[30] = 0; 
);

block_duration = samplesblock * inv_srate;
gmem[31] != last_h_tick ? (
  has_master = 1; last_h_tick = gmem[31]; m_watchdog_time = 0;
) : (
  m_watchdog_time += block_duration;
  m_watchdog_time > 0.5 ? has_master = 0; 
);

t_topo == 2 && gmem[30] != instance_id ? (
  t_topo = 1; slider_automate(t_topo);
  topo_offset = (t_calib_mode == 1) ? -4.0 : 0.0;
  target_calib = 10^((t_drive + topo_offset) / 20);
  target_out = 10^((t_out_gain - t_drive - topo_offset) / 20);
);

gmem[7] != last_global_bypass ? ( t_bypass = gmem[7]; last_global_bypass = gmem[7]; slider_automate(t_bypass); );
gmem[21] != last_global_xtalk ? ( t_xtalk = gmem[21]; last_global_xtalk = t_xtalk; slider_automate(t_xtalk); );
gmem[23] != last_global_xt_mode ? (
  t_topo != 2 ? ( t_xt_mode = gmem[23]; slider_automate(t_xt_mode); );
  last_global_xt_mode = gmem[23];
);

target_xt_db = (t_xt_mode == 0) ? -75.0 : (t_xt_mode == 1) ? -95.0 : -115.0;
xt_gain = 10^(target_xt_db/20);

gmem[22] != last_global_calib ? ( 
  t_calib_mode = gmem[22]; last_global_calib = t_calib_mode; slider_automate(t_calib_mode); 
  t_topo == 1 ? topo_offset = (t_calib_mode == 1) ? -4.0 : 0.0;
  t_topo == 2 ? topo_offset = -8.0;
  t_topo == 0 ? topo_offset = 0.0;
  target_calib = 10^((t_drive + topo_offset) / 20);
  target_out = 10^((t_out_gain - t_drive - topo_offset) / 20);
);

target_flux = t_flux / 100; target_thermal = t_thermal / 100; target_analog = t_analog / 100; target_bypass = 1.0 - t_bypass;
topology_interstage = t_topo == 0 ? 1.0 : 0.85; 
topology_flux_depth = t_topo == 0 ? 1.0 : 0.3; 

t_bypass == 0 ? ( atomic_add(gmem[10], energy_accum * 0.000015); );
energy_accum = 0;
t_topo == 2 ? ( gmem[10] *= pow(0.998, samplesblock); );
rail_target = gmem[10];

@sample
rawL = spl0; rawR = spl1;
s_flux = s_flux * smooth + target_flux * (1 - smooth);
s_thermal = s_thermal * smooth + target_thermal * (1 - smooth);
s_analog = s_analog * smooth + target_analog * (1 - smooth);
s_calib = s_calib * smooth + target_calib * (1 - smooth);
s_out = s_out * smooth + target_out * (1 - smooth);
s_bypass = s_bypass * smooth + target_bypass * (1 - smooth);

sL = rawL * s_calib; sR = rawR * s_calib;
dryL = sL; dryR = sR; 
peak = max(abs(sL), abs(sR));
meter_input = (peak > meter_input) ? (meter_input * 0.4 + peak * 0.6) : (meter_input * 0.9992 + peak * 0.0008);

g_clock += 1;
t_topo == 2 && (g_clock > 128) ? ( 
  g_clock = 0;
  current_read = gmem[PTR_BANK]; // 0 or 1
  next_read = 1 - current_read; 
  xi = 0; loop(10, gmem[BANK_A_OFFSET + xi + (next_read * 100)] = 0; xi += 1; );
  gmem[PTR_BANK] = next_read;
);

xt_leak = 0;

(t_bypass == 0) ? (
  
  t_xtalk ? (
    read_bank_offset = gmem[PTR_BANK] * 100;      
    write_bank_offset = (1 - gmem[PTR_BANK]) * 100; 
    
    xt_mono = (sL + sR) * 0.5;
    xt_lp = xt_lp * 0.85 + xt_mono * 0.15;
    xt_hp = xt_hp * 0.98 + xt_lp * 0.02;
    xt_final = xt_lp - xt_hp;
    
    atomic_add(gmem[BANK_A_OFFSET + cluster_id + write_bank_offset], xt_final);
    xt_sum = gmem[BANK_A_OFFSET + cluster_id + read_bank_offset];
    xt_leak = (xt_sum - xt_final) * xt_gain;
    
    sL += xt_leak * s_bypass; 
    sR += xt_leak * s_bypass;
  );

  flux_freq = 16500 - (unit_seed * (6500 * topology_flux_depth)); 
  flux_coeff = (1 - s_flux * 0.12) * (flux_freq * inv_srate);
  apL_in = sL; sL = (apL_in * (flux_coeff - 1) + apL) / (1 + flux_coeff); apL = apL_in + sL * flux_coeff;
  apR_in = sR; sR = (apR_in * (flux_coeff - 1) + apR) / (1 + flux_coeff); apR = apR_in + sR * flux_coeff;

  buffered_rail += (rail_target - buffered_rail) * rail_loss;
  shared_sag = 1.0 / (1.0 + buffered_rail * 0.04);
  slew_t = ist_threshold_base * (2.40 - s_analog) * shared_sag * topology_interstage; 
  inL = (sL + lastL) * 0.5; inR = (sR + lastR) * 0.5;

  (flip == 0) ? (
    istL_A1 = (istL_A1 * (1 - firstStage)) + (inL * firstStage); inL = istL_A1;
    istL_A2 = (istL_A2 * (1 - iirAmount)) + (inL * iirAmount); inL = istL_A2;
    istL_A3 = (istL_A3 * (1 - iirAmount)) + (inL * iirAmount); inputL = istL_A3;
    sL = dryL - (inputL * s_analog);
    (sL - istL_A1 > slew_t) ? sL = istL_A1 + slew_t : (sL - istL_A1 < -slew_t) ? sL = istL_A1 - slew_t;
    istR_A1 = (istR_A1 * (1 - firstStage)) + (inR * firstStage); inR = istR_A1;
    istR_A2 = (istR_A2 * (1 - iirAmount)) + (inR * iirAmount); inR = istR_A2;
    istR_A3 = (istR_A3 * (1 - iirAmount)) + (inR * iirAmount); inputR = istR_A3;
    sR = dryR - (inputR * s_analog);
    (sR - istR_A1 > slew_t) ? sR = istR_A1 + slew_t : (sR - istR_A1 < -slew_t) ? sR = istR_A1 - slew_t;
  ) : (
    istL_B1 = (istL_B1 * (1 - firstStage)) + (inL * firstStage); inL = istL_B1;
    istL_B2 = (istL_B2 * (1 - iirAmount)) + (inL * iirAmount); inL = istL_B2;
    istL_B3 = (istL_B3 * (1 - iirAmount)) + (inL * iirAmount); inputL = istL_B3;
    sL = dryL - (inputL * s_analog);
    (sL - istL_B1 > slew_t) ? sL = istL_B1 + slew_t : (sL - istL_B1 < -slew_t) ? sL = istL_B1 - slew_t;
    istR_B1 = (istR_B1 * (1 - firstStage)) + (inR * firstStage); inR = istR_B1;
    istR_B2 = (istR_B2 * (1 - iirAmount)) + (inR * iirAmount); inR = istR_B2;
    istR_B3 = (istR_B3 * (1 - iirAmount)) + (inR * iirAmount); inputR = istR_B3;
    sR = dryR - (inputR * s_analog);
    (sR - istR_B1 > slew_t) ? sR = istR_B1 + slew_t : (sR - istR_B1 < -slew_t) ? sR = istR_B1 - slew_t;
  );
  flip = 1 - flip; lastL = sL; lastR = sR;

  absL = abs(sL); absR = abs(sR);
  heatL = (absL > heatL) ? (absL * 0.05 + heatL * 0.95) : (heatL * thermal_rel + absL * (1 - thermal_rel));
  heatR = (absR > heatR) ? (absR * 0.05 + heatR * 0.95) : (heatR * thermal_rel + absR * (1 - thermal_rel));
  bloomL = 1.0 + (heatL * s_thermal * (t_topo == 0 ? 0.5 : 0.6));
  bloomR = 1.0 + (heatR * s_thermal * (t_topo == 0 ? 0.5 : 0.6));
  sL *= 0.618; sL_target = 1.0 - min(abs(sL), 0.999); 
  (sL > 0.0) ? sL = -(exp(log(sL_target) * (1.618 * bloomL)) - 1) : sL = exp(log(1 + sL) * (1.618 * bloomL)) - 1;
  sR *= 0.618; sR_target = 1.0 - min(abs(sR), 0.999); 
  (sR > 0.0) ? sR = -(exp(log(sR_target) * (1.618 * bloomR)) - 1) : sR = exp(log(1 + sR) * (1.618 * bloomR)) - 1;
  
  current_energy = (abs(sL) + abs(sR)) * 0.5;
  energy_accum += current_energy;

) : (
  // --- STATE SCRUBBER PATH (Smart Decay & Snap) ---
  xt_lp *= 0.5; xt_hp *= 0.5;
  apL *= 0.5; apR *= 0.5;
  istL_A1 *= 0.5; istL_B1 *= 0.5; istL_A2 *= 0.5; istL_B2 *= 0.5;
  istR_A1 *= 0.5; istR_B1 *= 0.5; istR_A2 *= 0.5; istR_B2 *= 0.5;
  heatL *= 0.5; heatR *= 0.5;

  (abs(xt_lp) < 0.000000001) ? xt_lp = 0;
  (abs(xt_hp) < 0.000000001) ? xt_hp = 0;
  (abs(heatL) < 0.000000001) ? heatL = 0;
  (abs(heatR) < 0.000000001) ? heatR = 0;
  
  // FIX v1.8.1: FORCE INTERNAL SILENCE
  // Instead of passing a "ghost signal" (rawL * s_calib), we output 0.
  // This ensures procL is silence, and spl0 becomes pure rawL during bypass.
  sL = 0; sR = 0;
);

procL = sL * s_out; procR = sR * s_out;
hpL = hpL * 0.9999 + procL * 0.0001; hpR = hpR * 0.9999 + procR * 0.0001;
procL -= hpL; procR -= hpR;

spl0 = (procL * s_bypass) + (rawL * (1 - s_bypass));
spl1 = (procR * s_bypass) + (rawR * (1 - s_bypass));

@gfx 550 320
gfx_clear = 28 + 28*256 + 30*65536; 

function draw_meter(val, x, y, w, h, label, color_mode) (
  gfx_set(0.1, 0.1, 0.12, 1); gfx_rect(x, y, w, h); 
  v = min(val, 1.0);
  color_mode == 0 ? gfx_set(0, 0.7, 1, 1) : gfx_set(1, 0.5, 0, 1); 
  gfx_rect(x, y, v*w, h); 
  color_mode == 0 ? ( gfx_set(1, 1, 1, 0.8); gfx_rect(x + w * 0.8 - 1, y - 4, 2, h + 8); );
  gfx_set(1, 1, 1, 0.4); gfx_setfont(1, "Arial", 12);
  gfx_x = x; gfx_y = y - 18; gfx_drawstr(label);
);

function draw_button(x, y, w, h, active, label, r, g, b) (
  active == 2 ? gfx_set(r, g, b, 1) : gfx_set(0.15, 0.15, 0.18, 1);
  gfx_rect(x, y, w, h); 
  gfx_set(1, 1, 1, 0.05); gfx_line(x, y, x+w, y); 
  active == 1 ? ( gfx_set(r, g, b, 0.2); gfx_rect(x, y, w, h); gfx_set(r, g, b, 1); gfx_rect(x, y, 4, h); );
  gfx_set(1, 1, 1, active == 1 ? 1 : 0.4);
  gfx_setfont(1, "Arial", h > 25 ? 18 : 11, 'b');
  gfx_measurestr(label, lw, lh);
  gfx_x = x + (w - lw)/2; gfx_y = y + (h - lh)/2;
  gfx_drawstr(label);
);

function draw_small_button(x, y, w, h, active, label) (
  active ? gfx_set(0.4, 0.8, 0.4, 1) : gfx_set(0.2, 0.2, 0.25, 1);
  gfx_rect(x, y, w, h);
  gfx_set(1, 1, 1, 0.8);
  gfx_setfont(1, "Arial", 11);
  gfx_measurestr(label, lw, lh);
  gfx_x = x + (w - lw)/2; gfx_y = y + (h - lh)/2;
  gfx_drawstr(label);
);

gfx_set(1, 1, 1, 0.1); gfx_x = 10; gfx_y = 15; gfx_setfont(1, "Arial", 28, 'b');
gfx_drawstr("THE ANALOG MOLECULE");

// --- FLAVOR DISPLAY (UI) ---
flav_name = (t_flavor == 0) ? "CUSTOM / USER" : (t_flavor == 1) ? "BRITISH CLASS A" : (t_flavor == 2) ? "SOLID STATE E" : (t_flavor == 3) ? "US DISCRETE" : "MODERN MASTERING";
gfx_set(1, 1, 1, 0.6); gfx_setfont(1, "Arial", 12);
gfx_measurestr(flav_name, fw, fh);
gfx_x = 415 - fw; gfx_y = 10; 
gfx_drawstr(flav_name);

draw_small_button(420, 10, 20, 15, 0, "V");
(mouse_cap & 1 && !last_cap && mouse_x >= 420 && mouse_x <= 440 && mouse_y >= 10 && mouse_y <= 25) ? (
  gfx_x = mouse_x; gfx_y = mouse_y;
  sel = gfx_showmenu("Custom|British Class A|Solid State E|US Discrete|Modern Mastering");
  sel > 0 ? ( t_flavor = sel - 1; slider_automate(t_flavor); load_flavor(t_flavor); );
);

// --- LINK & TRIM UI ---
// LINK ALL TOGGLE
draw_small_button(450, 15, 80, 20, t_link_on, "LINK: ALL");
(mouse_cap & 1 && !last_cap && mouse_x >= 450 && mouse_x <= 530 && mouse_y >= 15 && mouse_y <= 35) ? (
  t_link_on = 1 - t_link_on; slider_automate(t_link_on);
);

// Link Scope & Trim (Only when Linked)
t_link_on ? (
  l_base = 5000;
  
  // FIX v3.8: SELF-PUBLISH ACTIVE STATE
  t_topo == 0 ? gmem[l_base+0] = 1;
  t_topo == 1 ? gmem[l_base+1] = 1;
  t_topo == 2 ? gmem[l_base+2] = 1;
  
  st_ch = gmem[l_base+0]; st_bus = gmem[l_base+1]; st_mtr = gmem[l_base+2];

  draw_small_button(450, 40, 25, 15, st_ch, "Ch");
  (mouse_cap & 1 && !last_cap && mouse_x >= 450 && mouse_x <= 475 && mouse_y >= 40 && mouse_y <= 55) ? ( 
    gmem[l_base+0] = 1 - gmem[l_base+0]; 
    // Force Wake Up: Channels
    gmem[70] = (gmem[l_base+0] == 1);
  );
  
  draw_small_button(477, 40, 26, 15, st_bus, "Bus");
  (mouse_cap & 1 && !last_cap && mouse_x >= 477 && mouse_x <= 503 && mouse_y >= 40 && mouse_y <= 55) ? ( 
    gmem[l_base+1] = 1 - gmem[l_base+1]; 
    // Force Wake Up: Buses
    gmem[71] = (gmem[l_base+1] == 1);
  );
  
  draw_small_button(505, 40, 25, 15, st_mtr, "Mtr");
  (mouse_cap & 1 && !last_cap && mouse_x >= 505 && mouse_x <= 530 && mouse_y >= 40 && mouse_y <= 55) ? ( 
    gmem[l_base+2] = 1 - gmem[l_base+2]; 
    // Force Wake Up: Master
    gmem[72] = (gmem[l_base+2] == 1);
  );

  draw_small_button(450, 58, 38, 15, 0, "<");
  (mouse_cap & 1 && !last_cap && mouse_x >= 450 && mouse_x <= 488 && mouse_y >= 58 && mouse_y <= 73) ? (
    // FIX v4.3: Micro Trim 0.025
    st_ch ? atomic_add(gmem[1000 + 3], -0.025);
    st_bus ? atomic_add(gmem[2000 + 3], -0.025);
    st_mtr ? atomic_add(gmem[3000 + 3], -0.025);
  );
  
  draw_small_button(492, 58, 38, 15, 0, ">");
  (mouse_cap & 1 && !last_cap && mouse_x >= 492 && mouse_x <= 530 && mouse_y >= 58 && mouse_y <= 73) ? (
    st_ch ? atomic_add(gmem[1000 + 3], 0.025);
    st_bus ? atomic_add(gmem[2000 + 3], 0.025);
    st_mtr ? atomic_add(gmem[3000 + 3], 0.025);
  );
);

// DUPLICATE ID WARNING UI (Bottom Right)
id_conflict == 1 ? (
  gfx_set(1, 0.2, 0.2, 1); gfx_setfont(1, "Arial", 11, 'b');
  warn_text = "ID DUPLICATE!";
  gfx_measurestr(warn_text, dw, dh);
  gfx_x = 500 - dw; gfx_y = 305; 
  gfx_drawstr(warn_text);
);

draw_meter(min(meter_input * 6.5, 1), 50, 75, 450, 12, "CIRCUIT DRIVE STRENGTH", 0);

r_col = t_bypass == 1 ? 1 : 0;
g_col = t_bypass == 1 ? 0.2 : 1;
b_col = t_bypass == 1 ? 0.2 : 0.5;
draw_button(50, 120, 450, 35, 1, t_bypass == 0 ? "MOLECULAR NETWORK: ACTIVE" : "GLOBAL BYPASS ENGAGED", r_col, g_col, b_col);
(mouse_cap & 1 && !last_cap && mouse_x >= 50 && mouse_x <= 500 && mouse_y >= 120 && mouse_y <= 155) ? ( t_bypass = 1 - t_bypass; gmem[7] = t_bypass; slider_automate(t_bypass); );

is_xt_visually_active = (t_xtalk == 1 && t_bypass == 0);
draw_button(50, 170, 450, 35, is_xt_visually_active, t_xtalk == 1 ? "ANALOG CROSSTALK: ON" : "ANALOG CROSSTALK: OFF", 0.8, 0.4, 1);
(mouse_cap & 1 && !last_cap && mouse_x >= 50 && mouse_x <= 500 && mouse_y >= 170 && mouse_y <= 205) ? ( t_xtalk = 1 - t_xtalk; gmem[21] = t_xtalk; slider_automate(t_xtalk); );

t_topo == 2 ? (
  mode_name = (t_xt_mode == 0) ? "MODE: VINTAGE (-75dB)" : (t_xt_mode == 1) ? "MODE: MODERN (-95dB)" : "MODE: BOUTIQUE (-115dB)";
  xt_mode_state = (t_xtalk == 1 && t_bypass == 0) ? 2 : 0;
  draw_button(50, 207, 450, 20, xt_mode_state, mode_name, 0.2, 0.35, 0.7);
  (mouse_cap & 1 && !last_cap && mouse_x >= 50 && mouse_x <= 500 && mouse_y >= 207 && mouse_y <= 227) ? ( 
    t_xt_mode = (t_xt_mode + 1) % 3; 
    slider_automate(t_xt_mode);
    gmem[23] = t_xt_mode; 
  );
  r_y = 235;
) : (
  gfx_set(1, 1, 1, 0.3); gfx_setfont(1, "Arial", 11);
  slave_mode = (t_xt_mode == 0) ? "VINTAGE" : (t_xt_mode == 1) ? "MODERN" : "BOUTIQUE";
  info_s = sprintf(#, "XT MODE SYNC: %s", slave_mode);
  gfx_measurestr(info_s, iw, ih);
  gfx_x = 50 + (450 - iw)/2; gfx_y = 210;
  gfx_drawstr(info_s);
  r_y = 230;
);

draw_button(50, r_y, 220, 35, 0, "REGEN ID (LOCAL)", 0, 0, 0);
(mouse_cap & 1 && !last_cap && mouse_x >= 50 && mouse_x <= 270 && mouse_y >= r_y && mouse_y <= r_y + 35) ? ( 
  t_id = floor(rand(180)) + 1; 
  slider_automate(t_id); 
  unit_seed = t_id / 180; 
  cluster_id = floor((t_id - 1) / 18); 
);

draw_button(280, r_y, 220, 35, 0, "RESHUFFLE ALL (GLOBAL)", 0.2, 0, 0);
(mouse_cap & 1 && !last_cap && mouse_x >= 280 && mouse_x <= 500 && mouse_y >= r_y && mouse_y <= r_y + 35) ? ( 
  gmem[11] = floor(rand(1000)); 
  gmem[1] = 0; 
  gmem[0] += 1; 
);

has_master == 0 ? (
  gfx_set(1, 0.2, 0.2, 1); gfx_setfont(1, "Arial", 13, 'b');
  warn_s = "WARNING: NO MASTER DETECTED (NETWORK SAG INACTIVE)";
  gfx_measurestr(warn_s, ww, wh);
  gfx_x = 50 + (450 - ww)/2; gfx_y = 275;
  gfx_drawstr(warn_s);
);

gfx_set(1, 1, 1, 0.05); gfx_rect(50, 295, 450, 1);
gfx_set(0.6, 0.6, 0.6, 1); gfx_setfont(1, "Arial", 12);
topo_str = t_topo == 0 ? "CHANNEL" : t_topo == 1 ? "BUS" : "MASTER";
cal_str = (t_topo == 1) ? (t_calib_mode == 0 ? " | CAL: HOT" : " | CAL: NORMAL") : "";
status_str = sprintf(#, "ID: %d | TOPO: %s%s | CLUSTER: %d", t_id, topo_str, cal_str, cluster_id + 1);
gfx_measurestr(status_str, sw, sh);
gfx_x = 50 + (450 - sw)/2; gfx_y = 305;
gfx_drawstr(status_str);

last_cap = mouse_cap;
