desc: The Hot Summer (DocShadrach)
// author: Doc Shadrach
// version: 1.8.1
// about: Analog-Like Stem Summer. 16-ch native routing. 
// 
// This plugin incorporates some DSP concepts
// derived from Airwindows by Chris Johnson, used under MIT License.
// Copyright (c) 2018 Chris Johnson
// Global network and physical rail architecture by Doc Shadrach.
//
// Copyright (c) 2025 DocShadrach
// All rights reserved.
// Licensed for use inside REAPER for personal or professional projects only.
// Modification, copying, redistribution, or creating derivative works is prohibited.
// See LICENSE file in the repository for full terms.

options:gmem=TheHotSummerNetwork

slider1:t_topo=0<0,1,1{Stem Sender (Bus),Master Summer (Main)}>Topology
slider2:t_mode=4<0,4,1{Signature,Vintage British,Discrete American,Modern Ultra-Linear,Master Controlled}>Console Flavor
slider3:t_stem=0<0,7,1{Stem 1 (3-4),Stem 2 (5-6),Stem 3 (7-8),Stem 4 (9-10),Stem 5 (11-12),Stem 6 (13-14),Stem 7 (15-16),Stem 8 (17-18)}>Stem ID
slider4:t_drive=0<-12,18,0.1>Compensated Drive (dB)

// --- PSU SECTION ---
slider5:t_psu_mode=0<0,3,1{Custom (Manual),Vintage (Sag),Modern (Punchy),Mastering (Linear)}>-Power Supply Type
slider6:t_stress=6<0,100,1>Bus Stress (Custom Only) %
slider7:t_inertia=250<1,1000,1>Rail Inertia (Custom Only) ms
// -------------------

slider8:t_xtalk=10<0,100,1>Inductive Crosstalk %
slider9:t_iron=15<0,80,1>Transformer Weight (Iron) %
slider10:t_delta=0<0,1,1{Normal Sum,Delta Monitor}>Signal Monitoring
slider11:t_bypass=0<0,1,1{Active Physical Summing,Clean Digital Sum}>Summing Mode
slider12:t_out_gain=0<-12,12,0.1>Master Output Gain (dB)
// Slider 13 (Oversampling) removed per request

// --- GRAVITY SECTION ---
slider14:t_gravity=0<0,100,0.1>Gravity (Density/Glue) %
slider15:t_grav_bypass=0<0,1,1>-Gravity Bypass State

in_pin:output L (Bus)
in_pin:output R (Bus)
in_pin:Stem 1 L
in_pin:Stem 1 R
in_pin:Stem 2 L
in_pin:Stem 2 R
in_pin:Stem 3 L
in_pin:Stem 3 R
in_pin:Stem 4 L
in_pin:Stem 4 R
in_pin:Stem 5 L
in_pin:Stem 5 R
in_pin:Stem 6 L
in_pin:Stem 6 R
in_pin:Stem 7 L
in_pin:Stem 7 R
in_pin:Stem 8 L
in_pin:Stem 8 R

out_pin:output L
out_pin:output R

@init
inv_srate = 1/srate;
log2_inv = 1 / log(2);
dith_const = 1.1 * pow(10, -44); 
half_pi = 1.57079632679;
fade_smooth = exp(-inv_srate / 0.005); 
// MOD v1.8.1: Corrected formula
denorm = pow(10, -30);

c2_iir_val = 0.0015 * (48000.0 * inv_srate);
led_thresh = 0.0000316;

param_smooth = exp(-inv_srate / 0.040); 
energy_smooth_coeff = exp(-inv_srate / 0.020);

nh_att = exp(-1/(srate * 0.1)); 
sum_wdL = 0; sum_wwL = 0;
sum_wdR = 0; sum_wwR = 0;

// State variables
lastL = 0; lastR = 0;
last_sumL = 0; last_sumR = 0; 
hL = 0; hR = 0;
rail_smooth = 1.0;
local_railL = 1.0; local_railR = 1.0; 
has_master_smooth = 1.0;
apL_state = 0; apR_state = 0;
dcL = 0; dcR = 0;
m_watchdog = 0;
has_master = 0;
last_master_tick = -1;
last_topo = -1;
// last_initialized_os removed
h_hystL = 0; h_hystR = 0;

// Optimization Cache
last_active_stems = -1;
cached_headroom = 1.0;

// Force update on first block
last_global_bypass = -1;
last_global_delta = -1;
last_global_inertia = -1;
// last_global_os removed

s_drive = 1.0;
s_recovery = 1.0;
s_iron_gain = 0.0;
s_xtalk_gain = 0.0;

// Gravity State
s_gravity = 0.0;
stem_gr_arr = freemem; freemem += 8;
i=0; loop(8, stem_gr_arr[i]=1.0; i+=1;);

// OVERSAMPLING FUNCTIONS REMOVED

// MEMORY ALLOCATION & CLEANUP
active_map = freemem; freemem += 8;
stem_vol = freemem; freemem += 8; 
stem_mute = freemem; freemem += 8; 
stem_solo = freemem; freemem += 8;
xtL_f1_arr = freemem; freemem += 8;
xtL_f2_arr = freemem; freemem += 8;
xtR_f1_arr = freemem; freemem += 8;
xtR_f2_arr = freemem; freemem += 8;
stem_energy_smooth_arr = freemem; freemem += 8;
drift_seed = freemem; freemem += 8;

i = 0; loop(8,
  active_map[i]=0; stem_vol[i]=0; stem_mute[i]=0; stem_solo[i]=0;
  xtL_f1_arr[i]=0; xtL_f2_arr[i]=0; xtR_f1_arr[i]=0; xtR_f2_arr[i]=0;
  stem_energy_smooth_arr[i]=0; drift_seed[i]=rand(1);
  i+=1; 
);

// Oversampling memory buffers removed
// mem_up_coeffs, mem_down_coeffs, mem_tmp, mem_hist_dL, mem_hist_dR removed

fpdL = 16386 + rand(2147483647); 
fpdR = 16386 + rand(2147483647); 

@slider
// VISIBILITY LOGIC
t_topo == 0 ? (
  // Removed reference to 4096 (old slider 13) to prevent UI ghosting
  slider_show(16 | 32 | 64 | 256 | 1024, 0); 
  slider_show(4 | 8, 1);
  
  // Hide Gravity Sliders in Stem Sender
  slider_show(8192 | 16384, 0);
) : (
  slider_show(4, 0); 
  slider_show(8 | 16, 1);
  
  t_psu_mode == 0 ? (
    slider_show(32 | 64, 1); // Show Stress & Inertia in Custom
  ) : (
    slider_show(32 | 64, 0); 
  );
  
  // Removed reference to 4096
  slider_show(128 | 256 | 512 | 1024 | 2048, 1);
  
  // Show Gravity Slider (Master)
  slider_show(8192, 1); 
  // Hide Gravity Bypass (Screen Only)
  slider_show(16384, 0);
);

gmem[16] = t_bypass;
gmem[17] = t_delta;
gmem[18] = t_inertia;
// gmem[19] (OS) removed

target_drive = pow(10, t_drive/20);

// REVERTED TO ORIGINAL LOGARITHMIC SCALE FOR BIT-PERFECT MATCH
// 0% = Off, 10% = -90dB, 100% = -45dB
target_xtalk_gain = (t_xtalk > 0) ? pow(10, (-95 + (t_xtalk * 0.5)) / 20) : 0.0;

target_iron_gain = (t_iron / 100);
s_out_gain = pow(10, (t_out_gain - 6.0) / 20); 

stem_bias_L = (t_stem - 3.2) * 0.01; 
stem_bias_R = (t_stem - 3.8) * 0.01; 

rail_inertia_coeff = exp(-inv_srate / (max(t_inertia, 1) / 1000));
local_inertiaL = rail_inertia_coeff * (0.99 + (t_stem * 0.001));
local_inertiaR = rail_inertia_coeff * (0.98 + (t_stem * 0.002));

// Filter initialization logic removed

t_topo != last_topo ? (
  t_topo == 1 && t_mode == 4 ? ( t_mode = 0; slider_automate(t_mode); );
  last_topo = t_topo;
);
t_topo == 1 ? ( g_mode_force = (t_mode == 4) ? 0 : t_mode; gmem[15] = g_mode_force; );

@block
gmem[16] != last_global_bypass ? (t_bypass = gmem[16]; slider_automate(t_bypass); last_global_bypass = t_bypass; );
gmem[17] != last_global_delta ? (t_delta = gmem[17]; slider_automate(t_delta); last_global_delta = t_delta; );
gmem[18] != last_global_inertia ? (
  t_inertia = gmem[18]; slider_automate(t_inertia); last_global_inertia = t_inertia;
  rail_inertia_coeff = exp(-inv_srate / (max(t_inertia, 1) / 1000));
  local_inertiaL = rail_inertia_coeff * (0.99 + (t_stem * 0.001));
  local_inertiaR = rail_inertia_coeff * (0.98 + (t_stem * 0.002));
);

// Global OS logic removed

drift_mod = sin(time_precise() * 0.05) * 0.001 + (1.0 - gmem[20]) * 0.0025; 

t_topo == 1 ? (
  g_tick = atomic_add(gmem[100], 1);
  any_solo = 0;
  ki = 0; loop(8,
    active_map[ki] = (g_tick - gmem[200 + ki] < 5) ? 1 : 0;
    stem_solo[ki] ? any_solo = 1;
    ki += 1;
  );
  g_mode_force = (t_mode == 4) ? 0 : t_mode;
  gmem[15] = g_mode_force;
) : (
  master_clock = gmem[100]; 
  gmem[200 + t_stem] = master_clock;
  master_clock == last_master_tick ? ( m_watchdog += 1; m_watchdog > 30 ? has_master = 0 : has_master = 1; ) : ( m_watchdog = 0; last_master_tick = master_clock; has_master = 1; );
);

@sample
s_drive = s_drive * param_smooth + target_drive * (1.0 - param_smooth);
s_recovery = 1.0 / s_drive;
s_iron_gain = s_iron_gain * param_smooth + target_iron_gain * (1.0 - param_smooth);
s_xtalk_gain = s_xtalk_gain * param_smooth + target_xtalk_gain * (1.0 - param_smooth);

// Smooth Gravity parameter
s_gravity = s_gravity * param_smooth + (t_gravity * 0.01) * (1.0 - param_smooth);

fpdL = (fpdL * 1103515245 + 12345) & 2147483647;
fpdR = (fpdR * 1103515245 + 12345) & 2147483647;
jitterL = (fpdL / 2147483647 - 0.5) * 0.0000001;
jitterR = (fpdR / 2147483647 - 0.5) * 0.0000001;

actual_mode = (t_topo == 0 && t_mode == 4) ? gmem[15] : t_mode;
(t_topo == 1 && actual_mode == 4) ? actual_mode = 0; 
headroom_offset = pow(10, -t_drive / 60); 

// --------------------------------------------------------------------------------
// TOPOLOGY 0: STEM SENDER
// --------------------------------------------------------------------------------
t_topo == 0 ? (
  
  t_bypass == 0 ? (
    // --- ACTIVE PROCESSING ---
    local_drift = (drift_seed[t_stem] * drift_mod);
    cur_energy = max(abs(spl0), abs(spl1));
    // MOD v1.8: Added Denorm Protection to Energy Follower
    stem_energy_smooth_arr[t_stem] = (stem_energy_smooth_arr[t_stem] * energy_smooth_coeff + cur_energy * (1.0 - energy_smooth_coeff)) + denorm;
    
    energy_factor = (actual_mode == 0) ? 1.05 : (actual_mode == 3) ? 1.2 : 1.35;
    eff_stem_drive = 1 + (s_drive - 1) * min(stem_energy_smooth_arr[t_stem] * energy_factor, 1);
    
    has_master_smooth = has_master_smooth * 0.99 + has_master * 0.01;
    gr = gmem[20]; (gr <= 0 || gr > 2.0) ? gr = 1.0;
    global_rail_raw = gr * has_master_smooth + (1.0 - has_master_smooth);
    local_railL = local_railL * local_inertiaL + global_rail_raw * (1.0 - local_inertiaL);
    local_railR = local_railR * local_inertiaR + global_rail_raw * (1.0 - local_inertiaR);
    
    // MOD: Oversampling Logic Removed. Always Native.
    sL = spl0 * eff_stem_drive; sR = spl1 * eff_stem_drive;
    clp = (0.68 * headroom_offset) + local_drift;
    abs(sL) > clp ? sL = (clp + (1-clp)*sin((abs(sL)-clp)/(1.5-clp)*half_pi))*sign(sL);
    abs(sR) > clp ? sR = (clp + (1-clp)*sin((abs(sR)-clp)/(1.5-clp)*half_pi))*sign(sR);
    
    slew_base = 0.50; 
    (actual_mode == 1) ? slew_base = 0.38;
    (actual_mode == 2) ? slew_base = 0.70;
    (actual_mode == 3) ? slew_base = 0.85;
    
    slew_mod = slew_base * (1 + local_drift * 4.5) * (headroom_offset * 0.5 + 0.5);
    slew_mod *= 2.2; 
    
    limitL = (slew_mod * local_railL) + jitterL;
    limitL = max(min(limitL, 0.99), 0.01);
    limitR = (slew_mod * local_railR) + jitterR;
    limitR = max(min(limitR, 0.99), 0.01);
    
    sL = lastL + (sL - lastL) * limitL; 
    sR = lastR + (sR - lastR) * limitR;
    lastL = sL; lastR = sR;

    actual_mode == 1 ? ( 
        sL += sL*sL * (0.05 + local_drift); 
        sR += sR*sR * (0.05 + local_drift); 
    );
    actual_mode == 2 ? ( 
        sL += (sL*sL * 0.04) + (sL*sL*sL * 0.35); 
        sR += (sR*sR * 0.04) + (sR*sR*sR * 0.35); 
    );
    
    sL = sL + (sL*sL * (stem_bias_L + local_drift)); sR = sR + (sR*sR * (stem_bias_R + local_drift));
    ap_cL = max(min(0.08 + (abs(sL)*0.05), 0.9), 0.01); ap_cR = max(min(0.08 + (abs(sR)*0.05), 0.9), 0.01);
    // MOD v1.8: Added Denorm to Allpass State
    oAL = ap_cL * sL + apL_state; apL_state = (sL - ap_cL * oAL) + denorm; sL = oAL;
    oAR = ap_cR * sR + apR_state; apR_state = (sR - ap_cR * oAR) + denorm; sR = oAR;
    sL = sin(max(min(sL * (local_railL + jitterL), 1.45), -1.45)); 
    sR = sin(max(min(sR * (local_railR + jitterR), 1.45), -1.45));
    spl0 = sL / eff_stem_drive; spl1 = sR / eff_stem_drive;

  ) : (
    // MOD v1.8: Replaced Flush-to-Zero with Additive Denorm
    lastL = (lastL * 0.5) + denorm; lastR = (lastR * 0.5) + denorm;
    apL_state = (apL_state * 0.5) + denorm; apR_state = (apR_state * 0.5) + denorm;
    
    spl0 = spl0; spl1 = spl1;
  );

// --------------------------------------------------------------------------------
// TOPOLOGY 1: MASTER SUMMER
// --------------------------------------------------------------------------------
) : (
  inL_raw = spl0; inR_raw = spl1;
  spl0 = 0; spl1 = 0; 
  
  sumL = 0; sumR = 0; dryL = 0; dryR = 0;
  active_stems = 0; total_demand = 0;
  
  // --- GRAVITY CONTEXT SETUP ---
  g_rail = gmem[20];
  g_stress_factor = (1.0 - g_rail) * 5.0; // 0.0 to ~1.0
  
  grav_thresh = 0.6 - (s_gravity * 0.4) - (g_stress_factor * 0.2 * s_gravity);
  grav_ratio = 1.5 + (s_gravity * 8.0) + (g_stress_factor * 4.0);
  grav_makeup = 1.0; 

  att_ms = 30 - (s_gravity * 29);
  rel_ms = 200 - (s_gravity * 150);
  gr_att = exp(-inv_srate / (att_ms * 0.001));
  gr_rel = exp(-inv_srate / (rel_ms * 0.001));

  j = 0; loop(8,
    is_active = active_map[j];
    target_v = (is_active && !stem_mute[j] && (any_solo == 0 || stem_solo[j])) ? 1.0 : 0.0;
    stem_vol[j] = stem_vol[j] * fade_smooth + target_v * (1.0 - fade_smooth);
    v = stem_vol[j];
    cL = spl(j*2 + 2) * v; cR = spl(j*2 + 3) * v;
    (v > 0.001) ? (
      active_stems += 1;
      dryL += cL; dryR += cR; 
      
      // Calculate Demand BEFORE compression (Correct Logic for PSU & Audit)
      total_demand += (abs(cL) + abs(cR)) * 0.5;
      
      // --- GRAVITY ENGINE ---
      // If Gravity is 0 or Bypassed, this block is skipped entirely.
      // Therefore, cL and cR remain identical to v1.4.
      (s_gravity > 0.01 && t_grav_bypass == 0) ? (
        stem_in = max(abs(cL), abs(cR));
        over = stem_in - grav_thresh;
        curr_gr = stem_gr_arr[j];
        
        target_gr = 1.0;
        over > 0 ? (
           reduced = over / grav_ratio;
           target_gr = (grav_thresh + reduced) / stem_in; 
        );
        
        (target_gr < curr_gr) ? (
             curr_gr = target_gr * gr_att + curr_gr * (1-gr_att);
        ) : (
             curr_gr = target_gr * gr_rel + curr_gr * (1-gr_rel);
        );

        stem_gr_arr[j] = curr_gr;
        
        // Wet path
        wetL = cL * curr_gr * grav_makeup;
        wetR = cR * curr_gr * grav_makeup;
        
        // Parallel Mix (MODIFIED: 70% Dry, 30% Wet)
        cL = (cL * 0.70) + (wetL * 0.30);
        cR = (cR * 0.70) + (wetR * 0.30);
      ) : (
        stem_gr_arr[j] = 1.0;
      );
      // ----------------------

      // CROSSTALK LOGIC (HIGHPASS SUBTRACTION)
      dynamic_xtalk = s_xtalk_gain; 
      xt_hp_coeff = 0.4; 
      // MOD v1.8: Added Denorm Protection to Crosstalk IIR
      xtL_f1_arr[j] += ((cL - xtL_f1_arr[j]) * xt_hp_coeff) + denorm; 
      xtL_high = cL - xtL_f1_arr[j]; 
      xtR_f1_arr[j] += ((cR - xtR_f1_arr[j]) * xt_hp_coeff) + denorm;
      xtR_high = cR - xtR_f1_arr[j];
      sumL += cL - (xtR_high * dynamic_xtalk * 0.5); 
      sumR += cR - (xtL_high * dynamic_xtalk * 0.5);
    );
    j += 1;
  );
  
  t_bypass == 0 ? (
    // --- POWER SUPPLY SIMULATION ---
    t_psu_mode == 0 ? (
      s_stress_mult = (t_stress / 100) * 5.0; 
      target_sag = 1.0 / (1.0 + (total_demand * s_stress_mult * 0.15));
      rail_inertia_coeff = exp(-inv_srate / (max(t_inertia, 1) / 1000));
    ) : t_psu_mode == 1 ? ( 
      target_sag = 1.0 / (1.0 + (total_demand * 0.5 * 0.15));
      rail_inertia_coeff = 0.9995; 
    ) : t_psu_mode == 2 ? (
      target_sag = 1.0 / (1.0 + (total_demand * 0.05 * 0.15));
      rail_inertia_coeff = 0.90; 
    ) : (
      target_sag = 1.0;
      rail_inertia_coeff = 0.0;
    );
    
    rail_smooth = rail_smooth * rail_inertia_coeff + target_sag * (1.0 - rail_inertia_coeff);
    gmem[20] = rail_smooth; 
    
    (active_stems != last_active_stems) ? (
      cached_headroom = active_stems > 1 ? 1 / pow(active_stems, 0.25) : 1.0;
      last_active_stems = active_stems;
    );
    sumL *= cached_headroom;
    sumR *= cached_headroom;

    delta_refL = sumL; delta_refR = sumR;
    base_sumL = sumL; base_sumR = sumR;

    // MOD: Oversampling Logic Removed. Always Native.
    proc_sumL = base_sumL; proc_sumR = base_sumR;
    proc_sumL *= s_drive; proc_sumR *= s_drive;
    proc_sumL = asin(max(min(proc_sumL, 0.999), -0.999));
    proc_sumR = asin(max(min(proc_sumR, 0.999), -0.999));
    
    slew_base = 0.50; 
    (actual_mode == 1) ? slew_base = 0.38;
    (actual_mode == 2) ? slew_base = 0.70;
    (actual_mode == 3) ? slew_base = 0.85;
    
    slew_mod = slew_base * (1 + (1.0 - rail_smooth) * 4.5) * (headroom_offset * 0.5 + 0.5);
    
    slew_mod *= 2.2;

    limitL = (slew_mod * rail_smooth); limitL = max(min(limitL, 0.99), 0.01);
    limitR = (slew_mod * rail_smooth); limitR = max(min(limitR, 0.99), 0.01);

    proc_sumL = last_sumL + (proc_sumL - last_sumL) * limitL; 
    proc_sumR = last_sumR + (proc_sumR - last_sumR) * limitR;
    last_sumL = proc_sumL; last_sumR = proc_sumR;

    actual_mode == 0 ? ( 
      proc_sumL += (proc_sumL*proc_sumL * 0.04) + (proc_sumL*proc_sumL*proc_sumL * 0.15); 
      proc_sumR += (proc_sumR*proc_sumR * 0.04) + (proc_sumR*proc_sumR*proc_sumR * 0.15); 
    );
    actual_mode == 1 ? ( proc_sumL += proc_sumL*proc_sumL * 0.08; proc_sumR += proc_sumR*proc_sumR * 0.08; );
    actual_mode == 2 ? ( proc_sumL += (proc_sumL*proc_sumL * 0.05) + (proc_sumL*proc_sumL*proc_sumL * 0.45); proc_sumR += (proc_sumR*proc_sumR * 0.05) + (proc_sumR*proc_sumR*proc_sumR * 0.45); );
    
    c2_sat = s_iron_gain * 0.95; 
    c2_scale = (1.0 - c2_sat); c2_scale *= c2_scale; 
    c2_scale = max(c2_scale, 0.001); 
    c2_dL = proc_sumL / c2_scale; c2_dR = proc_sumR / c2_scale;
    c2_iir = c2_iir_val; 
    
    // MOD v1.8: Updated Hysteresis Protection (Removed flush-to-zero, added Denorm)
    h_hystL = h_hystL * (1.0 - c2_iir) + c2_dL * c2_iir + denorm;
    h_hystR = h_hystR * (1.0 - c2_iir) + c2_dR * c2_iir + denorm;
    
    c2_dL = max(min(c2_dL, 1.57), -1.57);
    c2_dR = max(min(c2_dR, 1.57), -1.57);
    h_hystL = max(min(h_hystL, 1.57), -1.57);
    h_hystR = max(min(h_hystR, 1.57), -1.57);
    
    proc_sumL += (sin(c2_dL) - sin(h_hystL)) * c2_scale;
    proc_sumR += (sin(c2_dR) - sin(h_hystR)) * c2_scale;

    r_off = (1.0 - rail_smooth) * 0.12;
    xL = max(min(proc_sumL * (1.1 + r_off) / (headroom_offset * 0.5 + 0.5), 12), -12); e2L = exp(2*xL); proc_sumL = (e2L-1)/(e2L+1);
    xR = max(min(proc_sumR * (1.1 + r_off) / (headroom_offset * 0.5 + 0.5), 12), -12); e2R = exp(2*xR); proc_sumR = (e2R-1)/(e2R+1);
    proc_sumL *= s_recovery; proc_sumR *= s_recovery;
    sumL = proc_sumL; sumR = proc_sumR;
    
    // Automatic Makeup Gain
    makeup_gain = 1.0 / cached_headroom;
    sumL *= makeup_gain;
    sumR *= makeup_gain;
    
    // MOD v1.8: Added Denorm to Null Hunter State
    sum_wdL = sum_wdL * nh_att + (sumL * delta_refL) * (1 - nh_att) + denorm;
    sum_wwL = sum_wwL * nh_att + (sumL * sumL) * (1 - nh_att) + denorm;
    null_gainL = (sum_wwL > 0.000001) ? (sum_wdL / sum_wwL) : 1.0;
    sum_wdR = sum_wdR * nh_att + (sumR * delta_refR) * (1 - nh_att) + denorm;
    sum_wwR = sum_wwR * nh_att + (sumR * sumR) * (1 - nh_att) + denorm;
    null_gainR = (sum_wwR > 0.000001) ? (sum_wdR / sum_wwR) : 1.0;

    // MOD v1.8: Added Denorm to DC Blocker
    dcL = dcL * 0.9999 + sumL * 0.0001 + denorm; 
    dcR = dcR * 0.9999 + sumR * 0.0001 + denorm;
    sumL -= dcL; sumR -= dcR;
    absL = abs(sumL); int_exL = absL > 0 ? floor(log(absL) * log2_inv) : 0;
    fpdL = (fpdL * 1103515245 + 12345) & 2147483647;
    sumL += ((fpdL/2147483647.0 - 0.5) * dith_const * pow(2, int_exL + 62));
    absR = abs(sumR); int_exR = absR > 0 ? floor(log(absR) * log2_inv) : 0;
    fpdR = (fpdR * 1103515245 + 12345) & 2147483647;
    sumR += ((fpdR/2147483647.0 - 0.5) * dith_const * pow(2, int_exR + 62));
    
    t_delta == 1 ? ( 
      spl0 = (sumL * null_gainL - delta_refL) * s_out_gain; 
      spl1 = (sumR * null_gainR - delta_refR) * s_out_gain; 
    ) : ( 
      spl0 = sumL * s_out_gain; 
      spl1 = sumR * s_out_gain; 
    );
  ) : (
    // MASTER SUMMER BYPASS
    spl0 = dryL; spl1 = dryR; gmem[20] = 1.0;
    // MOD v1.8: Updated Bypass Decay to use Additive Denorm
    h_hystL = (h_hystL * 0.5) + denorm; h_hystR = (h_hystR * 0.5) + denorm;
    last_sumL = (last_sumL * 0.5) + denorm; last_sumR = (last_sumR * 0.5) + denorm; 
    
    k=0; loop(8, stem_gr_arr[k]=1.0; k+=1;);
  );
  k = 2; loop(16, spl(k) = 0; k += 1; );
);

@gfx 500 350
gfx_clear = 20 + 22*256 + 25*65536;
gfx_set(1, 1, 1, 0.4); gfx_setfont(1, "Arial", 32, 'b');
gfx_x = 20; gfx_y = 15; gfx_drawstr("THE HOT SUMMER");
gfx_setfont(1, "Arial", 12); gfx_x = 20; gfx_y = 55;
mouse_cap & 1 && !last_cap && mouse_x > 20 && mouse_x < 400 && mouse_y > 50 && mouse_y < 70 ? (
  t_bypass = 1 - t_bypass; gmem[16] = t_bypass; slider_automate(t_bypass);
);
t_bypass == 1 ? (
  gfx_set(1, 0.9, 0, 1); gfx_drawstr("SUMMING MODE: CLEAN DIGITAL SUM (GLOBAL SUMMER BYPASS)");
) : (
  t_delta == 1 ? (
    gfx_set(0.4, 0.8, 1, 1); gfx_drawstr("MONITORING: DELTA (ANALOG TEXTURE - NULL HUNTER ACTIVE)");
  ) : (
    t_topo == 0 ? (
      gfx_drawstr(sprintf(#, "MODE: STEM SENDER | STATUS: %s", has_master ? "SYNCED" : "OFFLINE"));
      t_mode == 4 ? (
        gfx_x = 20; gfx_y = 70; gfx_set(0.5, 0.8, 1, 1);
        m_name = (gmem[15] == 1) ? "VINTAGE BRITISH" : (gmem[15] == 2) ? "DISCRETE AMERICAN" : (gmem[15] == 3) ? "MODERN ULTRA-LINEAR" : "SIGNATURE";
        gfx_drawstr(sprintf(#, "SYNCED TO MASTER: %s", m_name));
      ) : (
        gfx_x = 20; gfx_y = 70; gfx_set(1, 0.6, 0.2, 1);
        m_name = (t_mode == 1) ? "VINTAGE BRITISH" : (t_mode == 2) ? "DISCRETE AMERICAN" : (t_mode == 3) ? "MODERN ULTRA-LINEAR" : "SIGNATURE";
        gfx_drawstr(sprintf(#, "CONSOLE OVERRIDE: %s", m_name));
      );
    ) : (
      gfx_drawstr(sprintf(#, "MODE: MASTER SUMMER | ACTIVE STEMS: %d | OUT GAIN: %+.1f dB", active_stems, t_out_gain));
      
      // WARNING UI IF WINDOW TOO SMALL
      (gfx_h < 250) ? (
        gfx_set(1, 0.3, 0.3, 1);
        gfx_setfont(1, "Arial", 11, 'b');
        txt = "EXPAND WINDOW â–¼";
        gfx_measurestr(txt, w, h);
        gfx_x = gfx_w - w - 10;
        gfx_y = 15;
        gfx_drawstr(txt);
      );

      t_mode == 4 ? (
        gfx_x = 20; gfx_y = 70; gfx_set(1, 0.3, 0.3, 1);
        gfx_drawstr("WARNING: MASTER CANNOT BE 'MASTER CONTROLLED'. FORCING SIGNATURE.");
      );
    );
  );
);
t_topo == 1 && t_bypass == 0 ? (
  i = 0; loop(8,
    vL = spl(i*2 + 2); vR = spl(i*2 + 3); act = abs(vL) + abs(vR);
    act_db = 20 * log10(max(act, 0.000001)); h_mtr = max(min((act_db + 80) * 1.5, 100), 4);
    
    x_pos = 34 + (i*55); y_mtr_bottom = 95; led_y = 100; led_x = x_pos + 22;
    
    active_map[i] ? (
      mouse_cap & 1 && !last_cap && sqrt((mouse_x-led_x)^2 + (mouse_y-led_y)^2) < 10 ? (
        stem_mute[i] = 1 - stem_mute[i];
      );
      mouse_cap & 1 && !last_cap && mouse_x > x_pos && mouse_x < x_pos+45 && mouse_y > led_y+15 && mouse_y < led_y+35 ? (
        stem_solo[i] = 1 - stem_solo[i];
      );
      
      (stem_solo[i] && stem_mute[i]) ? gfx_set(1, 0.5, 0, 1) : 
      stem_solo[i] ? gfx_set(1, 0.9, 0, 1) : 
      stem_mute[i] ? gfx_set(0.8, 0.1, 0.1, 1) : 
      (act > led_thresh ? gfx_set(0.2, 1, 0.4, 1) : gfx_set(0.1, 0.4, 0.2, 1));
      
    ) : ( gfx_set(0.2, 0.2, 0.2, 1); );
    gfx_circle(led_x, led_y, 7, 1); 
    active_map[i] ? (
      (stem_solo[i] && stem_mute[i]) ? gfx_set(1, 0.4, 0, 0.8) :
      stem_mute[i] ? gfx_set(0.4, 0.1, 0.1, 0.4) : 
      stem_solo[i] ? gfx_set(0.8, 0.7, 0.2, 0.8) : 
      (act > led_thresh ? gfx_set(0.2, 0.9, 0.4, 0.8) : gfx_set(0.2, 0.6, 0.3, 0.4));
    ) : ( gfx_set(0.3, 0.3, 0.3, 0.2); );
    gfx_rect(x_pos, y_mtr_bottom, 45, -h_mtr);
    s_label = sprintf(#, "S%d", i+1); gfx_measurestr(s_label, tw, th);
    gfx_x = led_x - tw/2; gfx_y = led_y + 25; 
    active_map[i] && stem_solo[i] ? gfx_set(1, 0.9, 0, 1) : gfx_set(1, 1, 1, 0.5);
    gfx_drawstr(s_label); i += 1;
  );
  
  gfx_set(1, 1, 1, 0.2); gfx_x = 20; gfx_y = 160;
  tempo > 0 ? (
    q_ms = 60000 / tempo;
    gfx_drawstr(sprintf(#, "TEMPO SYNC TIP: 1/4 = %dms | 1/8 = %dms", q_ms, q_ms/2));
  );
  
  gfx_set(1, 0.6, 0, 1); gfx_x = 20; gfx_y = 180;
  sag_percent = (1.0 - gmem[20]) * 100;
  gfx_drawstr(sprintf(#, "BUS STRESS (RAIL SAG): %.1f%%", sag_percent));
  
  gfx_set(0.1, 0.1, 0.1, 1); gfx_rect(20, 200, 460, 16);
  gfx_set(1, 0.4, 0, 1); 
  
  rail_vis = (1.0 - gmem[20]) * 5000; 
  gfx_rect(20, 200, min(rail_vis, 460), 16);
  
  // GRAVITY VISUAL (STATIC - MOVED UP TO FIT)
  t_gravity > 0 ? (
     gfx_set(0.5, 0.2, 1.0, 1); gfx_x = 20; gfx_y = 225;
     gfx_drawstr(sprintf(#, "GRAVITY ENGINE: %.1f%%", t_gravity));
     
     // GRAVITY BYPASS TOGGLE
     btn_x = 350; btn_y = 225; btn_w = 80; btn_h = 18;
     gfx_set(0.2, 0.2, 0.3, 1); gfx_rect(btn_x, btn_y, btn_w, btn_h);
     t_grav_bypass ? gfx_set(0.5, 0.2, 0.2, 1) : gfx_set(0.2, 0.8, 0.2, 1);
     gfx_rect(btn_x+2, btn_y+2, btn_w-4, btn_h-4);
     gfx_set(0,0,0,1); gfx_setfont(1, "Arial", 11, 'b');
     lbl = t_grav_bypass ? "BYPASSED" : "ACTIVE";
     gfx_measurestr(lbl, lw, lh); gfx_x = btn_x + (btn_w-lw)/2; gfx_y = btn_y + (btn_h-lh)/2;
     gfx_drawstr(lbl);
     
     (mouse_cap & 1 && !(last_mouse_cap & 1) && mouse_x >= btn_x && mouse_x <= btn_x+btn_w && mouse_y >= btn_y && mouse_y <= btn_y+btn_h) ? (
       t_grav_bypass = 1 - t_grav_bypass; slider_automate(t_grav_bypass);
     );

     // STATIC BAR ONLY - Shows how much Gravity is dialed in
     gfx_set(0.5, 0.2, 1.0, 1);
     bar_w = 460 * (t_gravity/100);
     gfx_rect(20, 245, bar_w, 4);
  );
);
last_cap = mouse_cap;
